"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsonpath-plus";
exports.ids = ["vendor-chunks/jsonpath-plus"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsonpath-plus/dist/index-node-cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/jsonpath-plus/dist/index-node-cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar vm = __webpack_require__(/*! vm */ \"vm\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar vm__default = /*#__PURE__*/_interopDefaultLegacy(vm);\n\nconst {\n  hasOwnProperty: hasOwnProp\n} = Object.prototype;\n/**\n* @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject\n*/\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {any} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\n\nfunction push(arr, item) {\n  arr = arr.slice();\n  arr.push(item);\n  return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {any} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\n\n\nfunction unshift(item, arr) {\n  arr = arr.slice();\n  arr.unshift(item);\n  return arr;\n}\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\n\n\nclass NewError extends Error {\n  /**\n   * @param {any} value The evaluated scalar value\n   */\n  constructor(value) {\n    super('JSONPath should not be called with \"new\" (it prevents return ' + 'of (unwrapped) scalar values)');\n    this.avoidNew = true;\n    this.value = value;\n    this.name = 'NewError';\n  }\n\n}\n/**\n* @typedef {PlainObject} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {PlainObject|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|PlainObject} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {PlainObject|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/* eslint-disable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @typedef {PlainObject} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {PlainObject} [sandbox={}]\n * @property {boolean} [preventEval=false]\n * @property {PlainObject|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n\n/* eslint-enable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\n\n\nfunction JSONPath(opts, expr, obj, callback, otherTypeCallback) {\n  // eslint-disable-next-line no-restricted-syntax\n  if (!(this instanceof JSONPath)) {\n    try {\n      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n    } catch (e) {\n      if (!e.avoidNew) {\n        throw e;\n      }\n\n      return e.value;\n    }\n  }\n\n  if (typeof opts === 'string') {\n    otherTypeCallback = callback;\n    callback = obj;\n    obj = expr;\n    expr = opts;\n    opts = null;\n  }\n\n  const optObj = opts && typeof opts === 'object';\n  opts = opts || {};\n  this.json = opts.json || obj;\n  this.path = opts.path || expr;\n  this.resultType = opts.resultType || 'value';\n  this.flatten = opts.flatten || false;\n  this.wrap = hasOwnProp.call(opts, 'wrap') ? opts.wrap : true;\n  this.sandbox = opts.sandbox || {};\n  this.preventEval = opts.preventEval || false;\n  this.parent = opts.parent || null;\n  this.parentProperty = opts.parentProperty || null;\n  this.callback = opts.callback || callback || null;\n\n  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {\n    throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');\n  };\n\n  if (opts.autostart !== false) {\n    const args = {\n      path: optObj ? opts.path : expr\n    };\n\n    if (!optObj) {\n      args.json = obj;\n    } else if ('json' in opts) {\n      args.json = opts.json;\n    }\n\n    const ret = this.evaluate(args);\n\n    if (!ret || typeof ret !== 'object') {\n      throw new NewError(ret);\n    }\n\n    return ret;\n  }\n} // PUBLIC METHODS\n\n\nJSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {\n  let currParent = this.parent,\n      currParentProperty = this.parentProperty;\n  let {\n    flatten,\n    wrap\n  } = this;\n  this.currResultType = this.resultType;\n  this.currPreventEval = this.preventEval;\n  this.currSandbox = this.sandbox;\n  callback = callback || this.callback;\n  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n  json = json || this.json;\n  expr = expr || this.path;\n\n  if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\n    if (!expr.path && expr.path !== '') {\n      throw new TypeError('You must supply a \"path\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n\n    if (!hasOwnProp.call(expr, 'json')) {\n      throw new TypeError('You must supply a \"json\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n\n    ({\n      json\n    } = expr);\n    flatten = hasOwnProp.call(expr, 'flatten') ? expr.flatten : flatten;\n    this.currResultType = hasOwnProp.call(expr, 'resultType') ? expr.resultType : this.currResultType;\n    this.currSandbox = hasOwnProp.call(expr, 'sandbox') ? expr.sandbox : this.currSandbox;\n    wrap = hasOwnProp.call(expr, 'wrap') ? expr.wrap : wrap;\n    this.currPreventEval = hasOwnProp.call(expr, 'preventEval') ? expr.preventEval : this.currPreventEval;\n    callback = hasOwnProp.call(expr, 'callback') ? expr.callback : callback;\n    this.currOtherTypeCallback = hasOwnProp.call(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;\n    currParent = hasOwnProp.call(expr, 'parent') ? expr.parent : currParent;\n    currParentProperty = hasOwnProp.call(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;\n    expr = expr.path;\n  }\n\n  currParent = currParent || null;\n  currParentProperty = currParentProperty || null;\n\n  if (Array.isArray(expr)) {\n    expr = JSONPath.toPathString(expr);\n  }\n\n  if (!expr && expr !== '' || !json) {\n    return undefined;\n  }\n\n  const exprList = JSONPath.toPathArray(expr);\n\n  if (exprList[0] === '$' && exprList.length > 1) {\n    exprList.shift();\n  }\n\n  this._hasParentSelector = null;\n\n  const result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {\n    return ea && !ea.isParentSelector;\n  });\n\n  if (!result.length) {\n    return wrap ? [] : undefined;\n  }\n\n  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n    return this._getPreferredOutput(result[0]);\n  }\n\n  return result.reduce((rslt, ea) => {\n    const valOrPath = this._getPreferredOutput(ea);\n\n    if (flatten && Array.isArray(valOrPath)) {\n      rslt = rslt.concat(valOrPath);\n    } else {\n      rslt.push(valOrPath);\n    }\n\n    return rslt;\n  }, []);\n}; // PRIVATE METHODS\n\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n  const resultType = this.currResultType;\n\n  switch (resultType) {\n    case 'all':\n      {\n        const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);\n        ea.pointer = JSONPath.toPointer(path);\n        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);\n        return ea;\n      }\n\n    case 'value':\n    case 'parent':\n    case 'parentProperty':\n      return ea[resultType];\n\n    case 'path':\n      return JSONPath.toPathString(ea[resultType]);\n\n    case 'pointer':\n      return JSONPath.toPointer(ea.path);\n\n    default:\n      throw new TypeError('Unknown result type');\n  }\n};\n\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n  if (callback) {\n    const preferredOutput = this._getPreferredOutput(fullRetObj);\n\n    fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path); // eslint-disable-next-line node/callback-return\n\n    callback(preferredOutput, type, fullRetObj);\n  }\n};\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {PlainObject|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\n\n\nJSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {\n  // No expr to follow? return path and value as the result of\n  //  this trace branch\n  let retObj;\n\n  if (!expr.length) {\n    retObj = {\n      path,\n      value: val,\n      parent,\n      parentProperty: parentPropName,\n      hasArrExpr\n    };\n\n    this._handleCallback(retObj, callback, 'value');\n\n    return retObj;\n  }\n\n  const loc = expr[0],\n        x = expr.slice(1); // We need to gather the return value of recursive trace calls in order to\n  // do the parent sel computation.\n\n  const ret = [];\n  /**\n   *\n   * @param {ReturnObject|ReturnObject[]} elems\n   * @returns {void}\n   */\n\n  function addRet(elems) {\n    if (Array.isArray(elems)) {\n      // This was causing excessive stack size in Node (with or\n      //  without Babel) against our performance test:\n      //  `ret.push(...elems);`\n      elems.forEach(t => {\n        ret.push(t);\n      });\n    } else {\n      ret.push(elems);\n    }\n  }\n\n  if ((typeof loc !== 'string' || literalPriority) && val && hasOwnProp.call(val, loc)) {\n    // simple case--directly follow property\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr)); // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n  } else if (loc === '*') {\n    // all child properties\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true, true));\n    });\n  } else if (loc === '..') {\n    // all descendent parent properties\n    // Check remaining expression with val's immediate children\n    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));\n\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      // We don't join m and x here because we only want parents,\n      //   not scalar values\n      if (typeof v[m] === 'object') {\n        // Keep going with recursive descent on val's\n        //   object children\n        addRet(this._trace(unshift(l, _x), v[m], push(p, m), v, m, cb, true));\n      }\n    }); // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n\n  } else if (loc === '^') {\n    // This is not a final endpoint, so we do not invoke the callback here\n    this._hasParentSelector = true;\n    return {\n      path: path.slice(0, -1),\n      expr: x,\n      isParentSelector: true\n    };\n  } else if (loc === '~') {\n    // property name\n    retObj = {\n      path: push(path, loc),\n      value: parentPropName,\n      parent,\n      parentProperty: null\n    };\n\n    this._handleCallback(retObj, callback, 'property');\n\n    return retObj;\n  } else if (loc === '$') {\n    // root only\n    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n  } else if (/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(loc)) {\n    // [start:end:step]  Python slice syntax\n    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));\n  } else if (loc.indexOf('?(') === 0) {\n    // [?(expr)] (filtering)\n    if (this.currPreventEval) {\n      throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n    }\n\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      if (this._eval(l.replace(/^\\?\\((.*?)\\)$/u, '$1'), v[m], m, p, par, pr)) {\n        addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true));\n      }\n    });\n  } else if (loc[0] === '(') {\n    // [(expr)] (dynamic property/index)\n    if (this.currPreventEval) {\n      throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n    } // As this will resolve to a property name (but we don't know it\n    //  yet), property and parent information is relative to the\n    //  parent of the property to which this expression will resolve\n\n\n    addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));\n  } else if (loc[0] === '@') {\n    // value type: @boolean(), etc.\n    let addType = false;\n    const valueType = loc.slice(1, -2);\n\n    switch (valueType) {\n      case 'scalar':\n        if (!val || !['object', 'function'].includes(typeof val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'boolean':\n      case 'string':\n      case 'undefined':\n      case 'function':\n        // eslint-disable-next-line valid-typeof\n        if (typeof val === valueType) {\n          addType = true;\n        }\n\n        break;\n\n      case 'integer':\n        if (Number.isFinite(val) && !(val % 1)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'number':\n        if (Number.isFinite(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'nonFinite':\n        if (typeof val === 'number' && !Number.isFinite(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'object':\n        // eslint-disable-next-line valid-typeof\n        if (val && typeof val === valueType) {\n          addType = true;\n        }\n\n        break;\n\n      case 'array':\n        if (Array.isArray(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'other':\n        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);\n        break;\n\n      case 'null':\n        if (val === null) {\n          addType = true;\n        }\n\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new TypeError('Unknown value type ' + valueType);\n    }\n\n    if (addType) {\n      retObj = {\n        path,\n        value: val,\n        parent,\n        parentProperty: parentPropName\n      };\n\n      this._handleCallback(retObj, callback, 'value');\n\n      return retObj;\n    } // `-escaped property\n\n  } else if (loc[0] === '`' && val && hasOwnProp.call(val, loc.slice(1))) {\n    const locProp = loc.slice(1);\n    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));\n  } else if (loc.includes(',')) {\n    // [name1,name2,...]\n    const parts = loc.split(',');\n\n    for (const part of parts) {\n      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));\n    } // simple case--directly follow property\n\n  } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));\n  } // We check the resulting values for parent selections. For parent\n  // selections we discard the value object and continue the trace with the\n  // current val object\n\n\n  if (this._hasParentSelector) {\n    for (let t = 0; t < ret.length; t++) {\n      const rett = ret[t];\n\n      if (rett && rett.isParentSelector) {\n        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);\n\n        if (Array.isArray(tmp)) {\n          ret[t] = tmp[0];\n          const tl = tmp.length;\n\n          for (let tt = 1; tt < tl; tt++) {\n            t++;\n            ret.splice(t, 0, tmp[tt]);\n          }\n        } else {\n          ret[t] = tmp;\n        }\n      }\n    }\n  }\n\n  return ret;\n};\n\nJSONPath.prototype._walk = function (loc, expr, val, path, parent, parentPropName, callback, f) {\n  if (Array.isArray(val)) {\n    const n = val.length;\n\n    for (let i = 0; i < n; i++) {\n      f(i, loc, expr, val, path, parent, parentPropName, callback);\n    }\n  } else if (val && typeof val === 'object') {\n    Object.keys(val).forEach(m => {\n      f(m, loc, expr, val, path, parent, parentPropName, callback);\n    });\n  }\n};\n\nJSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {\n  if (!Array.isArray(val)) {\n    return undefined;\n  }\n\n  const len = val.length,\n        parts = loc.split(':'),\n        step = parts[2] && Number.parseInt(parts[2]) || 1;\n  let start = parts[0] && Number.parseInt(parts[0]) || 0,\n      end = parts[1] && Number.parseInt(parts[1]) || len;\n  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);\n  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);\n  const ret = [];\n\n  for (let i = start; i < end; i += step) {\n    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true); // Should only be possible to be an array here since first part of\n    //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n    //     nor begin with `@` (as could return objects)\n    // This was causing excessive stack size in Node (with or\n    //  without Babel) against our performance test: `ret.push(...tmp);`\n\n\n    tmp.forEach(t => {\n      ret.push(t);\n    });\n  }\n\n  return ret;\n};\n\nJSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {\n  if (code.includes('@parentProperty')) {\n    this.currSandbox._$_parentProperty = parentPropName;\n    code = code.replace(/@parentProperty/gu, '_$_parentProperty');\n  }\n\n  if (code.includes('@parent')) {\n    this.currSandbox._$_parent = parent;\n    code = code.replace(/@parent/gu, '_$_parent');\n  }\n\n  if (code.includes('@property')) {\n    this.currSandbox._$_property = _vname;\n    code = code.replace(/@property/gu, '_$_property');\n  }\n\n  if (code.includes('@path')) {\n    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n    code = code.replace(/@path/gu, '_$_path');\n  }\n\n  if (code.includes('@root')) {\n    this.currSandbox._$_root = this.json;\n    code = code.replace(/@root/gu, '_$_root');\n  }\n\n  if (/@([.\\s)[])/u.test(code)) {\n    this.currSandbox._$_v = _v;\n    code = code.replace(/@([.\\s)[])/gu, '_$_v$1');\n  }\n\n  try {\n    return this.vm.runInNewContext(code, this.currSandbox);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.log(e);\n    throw new Error('jsonPath: ' + e.message + ': ' + code);\n  }\n}; // PUBLIC CLASS PROPERTIES AND METHODS\n// Could store the cache object itself\n\n\nJSONPath.cache = {};\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\n\nJSONPath.toPathString = function (pathArr) {\n  const x = pathArr,\n        n = x.length;\n  let p = '$';\n\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += /^[0-9*]+$/u.test(x[i]) ? '[' + x[i] + ']' : \"['\" + x[i] + \"']\";\n    }\n  }\n\n  return p;\n};\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\n\n\nJSONPath.toPointer = function (pointer) {\n  const x = pointer,\n        n = x.length;\n  let p = '';\n\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += '/' + x[i].toString().replace(/~/gu, '~0').replace(/\\//gu, '~1');\n    }\n  }\n\n  return p;\n};\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\n\n\nJSONPath.toPathArray = function (expr) {\n  const {\n    cache\n  } = JSONPath;\n\n  if (cache[expr]) {\n    return cache[expr].concat();\n  }\n\n  const subx = [];\n  const normalized = expr // Properties\n  .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu, ';$&;') // Parenthetical evaluations (filtering and otherwise), directly\n  //   within brackets or single quotes\n  .replace(/[['](\\??\\(.*?\\))[\\]']/gu, function ($0, $1) {\n    return '[#' + (subx.push($1) - 1) + ']';\n  }) // Escape periods and tildes within properties\n  .replace(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n    return \"['\" + prop.replace(/\\./gu, '%@%').replace(/~/gu, '%%@@%%') + \"']\";\n  }) // Properties operator\n  .replace(/~/gu, ';~;') // Split by property boundaries\n  .replace(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';') // Reinsert periods within properties\n  .replace(/%@%/gu, '.') // Reinsert tildes within properties\n  .replace(/%%@@%%/gu, '~') // Parent\n  .replace(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n    return ';' + ups.split('').join(';') + ';';\n  }) // Descendents\n  .replace(/;;;|;;/gu, ';..;') // Remove trailing\n  .replace(/;$|'?\\]|'$/gu, '');\n  const exprList = normalized.split(';').map(function (exp) {\n    const match = exp.match(/#(\\d+)/u);\n    return !match || !match[1] ? exp : subx[match[1]];\n  });\n  cache[expr] = exprList;\n  return cache[expr].concat();\n};\n\nJSONPath.prototype.vm = vm__default['default'];\n\nexports.JSONPath = JSONPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnBhdGgtcGx1cy9kaXN0L2luZGV4LW5vZGUtY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsU0FBUyxtQkFBTyxDQUFDLGNBQUk7O0FBRXJCLHFDQUFxQyw0REFBNEQ7O0FBRWpHOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxZQUFZLHFEQUFxRDtBQUNqRTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsS0FBSztBQUNoQixhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QixhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsY0FBYztBQUN4QixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QixVQUFVLFFBQVE7QUFDbEIsVUFBVSwwQkFBMEI7QUFDcEMsVUFBVSxRQUFRO0FBQ2xCLFlBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjLE1BQU07QUFDcEIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYywwREFBMEQ7QUFDeEUsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLGFBQWEsV0FBVztBQUN0Qyxj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Q0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxSEFBcUgsR0FBRztBQUN4SDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0IsRUFBRTtBQUN0QixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLGFBQWEseUJBQXlCLE9BQU87QUFDN0MsR0FBRztBQUNILGVBQWUsR0FBRyxPQUFPLEdBQUc7QUFDNUIsYUFBYTtBQUNiLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXgtY21zLW5leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qc29ucGF0aC1wbHVzL2Rpc3QvaW5kZXgtbm9kZS1janMuanM/YzM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2bSA9IHJlcXVpcmUoJ3ZtJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgdm1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHZtKTtcblxuY29uc3Qge1xuICBoYXNPd25Qcm9wZXJ0eTogaGFzT3duUHJvcFxufSA9IE9iamVjdC5wcm90b3R5cGU7XG4vKipcbiogQHR5cGVkZWYge251bGx8Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfFBsYWluT2JqZWN0fEdlbmVyaWNBcnJheX0gSlNPTk9iamVjdFxuKi9cblxuLyoqXG4gKiBDb3BpZXMgYXJyYXkgYW5kIHRoZW4gcHVzaGVzIGl0ZW0gaW50byBpdC5cbiAqIEBwYXJhbSB7R2VuZXJpY0FycmF5fSBhcnIgQXJyYXkgdG8gY29weSBhbmQgaW50byB3aGljaCB0byBwdXNoXG4gKiBAcGFyYW0ge2FueX0gaXRlbSBBcnJheSBpdGVtIHRvIGFkZCAodG8gZW5kKVxuICogQHJldHVybnMge0dlbmVyaWNBcnJheX0gQ29weSBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBwdXNoKGFyciwgaXRlbSkge1xuICBhcnIgPSBhcnIuc2xpY2UoKTtcbiAgYXJyLnB1c2goaXRlbSk7XG4gIHJldHVybiBhcnI7XG59XG4vKipcbiAqIENvcGllcyBhcnJheSBhbmQgdGhlbiB1bnNoaWZ0cyBpdGVtIGludG8gaXQuXG4gKiBAcGFyYW0ge2FueX0gaXRlbSBBcnJheSBpdGVtIHRvIGFkZCAodG8gYmVnaW5uaW5nKVxuICogQHBhcmFtIHtHZW5lcmljQXJyYXl9IGFyciBBcnJheSB0byBjb3B5IGFuZCBpbnRvIHdoaWNoIHRvIHVuc2hpZnRcbiAqIEByZXR1cm5zIHtHZW5lcmljQXJyYXl9IENvcHkgb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB1bnNoaWZ0KGl0ZW0sIGFycikge1xuICBhcnIgPSBhcnIuc2xpY2UoKTtcbiAgYXJyLnVuc2hpZnQoaXRlbSk7XG4gIHJldHVybiBhcnI7XG59XG4vKipcbiAqIENhdWdodCB3aGVuIEpTT05QYXRoIGlzIHVzZWQgd2l0aG91dCBgbmV3YCBidXQgcmV0aHJvd24gaWYgd2l0aCBgbmV3YFxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xuXG5cbmNsYXNzIE5ld0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBldmFsdWF0ZWQgc2NhbGFyIHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCdKU09OUGF0aCBzaG91bGQgbm90IGJlIGNhbGxlZCB3aXRoIFwibmV3XCIgKGl0IHByZXZlbnRzIHJldHVybiAnICsgJ29mICh1bndyYXBwZWQpIHNjYWxhciB2YWx1ZXMpJyk7XG4gICAgdGhpcy5hdm9pZE5ldyA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmFtZSA9ICdOZXdFcnJvcic7XG4gIH1cblxufVxuLyoqXG4qIEB0eXBlZGVmIHtQbGFpbk9iamVjdH0gUmV0dXJuT2JqZWN0XG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoXG4qIEBwcm9wZXJ0eSB7SlNPTk9iamVjdH0gdmFsdWVcbiogQHByb3BlcnR5IHtQbGFpbk9iamVjdHxHZW5lcmljQXJyYXl9IHBhcmVudFxuKiBAcHJvcGVydHkge3N0cmluZ30gcGFyZW50UHJvcGVydHlcbiovXG5cbi8qKlxuKiBAY2FsbGJhY2sgSlNPTlBhdGhDYWxsYmFja1xuKiBAcGFyYW0ge3N0cmluZ3xQbGFpbk9iamVjdH0gcHJlZmVycmVkT3V0cHV0XG4qIEBwYXJhbSB7XCJ2YWx1ZVwifFwicHJvcGVydHlcIn0gdHlwZVxuKiBAcGFyYW0ge1JldHVybk9iamVjdH0gZnVsbFJldE9ialxuKiBAcmV0dXJucyB7dm9pZH1cbiovXG5cbi8qKlxuKiBAY2FsbGJhY2sgT3RoZXJUeXBlQ2FsbGJhY2tcbiogQHBhcmFtIHtKU09OT2JqZWN0fSB2YWxcbiogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiogQHBhcmFtIHtQbGFpbk9iamVjdHxHZW5lcmljQXJyYXl9IHBhcmVudFxuKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50UHJvcE5hbWVcbiogQHJldHVybnMge2Jvb2xlYW59XG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuIC0tIENhbiBtYWtlIG11bHRpbGluZSB0eXBlIGFmdGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9zeWF2b3Jza3kvY29tbWVudC1wYXJzZXIvaXNzdWVzLzEwOSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtQbGFpbk9iamVjdH0gSlNPTlBhdGhPcHRpb25zXG4gKiBAcHJvcGVydHkge0pTT059IGpzb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoXG4gKiBAcHJvcGVydHkge1widmFsdWVcInxcInBhdGhcInxcInBvaW50ZXJcInxcInBhcmVudFwifFwicGFyZW50UHJvcGVydHlcInxcImFsbFwifSBbcmVzdWx0VHlwZT1cInZhbHVlXCJdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmbGF0dGVuPWZhbHNlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcD10cnVlXVxuICogQHByb3BlcnR5IHtQbGFpbk9iamVjdH0gW3NhbmRib3g9e31dXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmV2ZW50RXZhbD1mYWxzZV1cbiAqIEBwcm9wZXJ0eSB7UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fG51bGx9IFtwYXJlbnQ9bnVsbF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtwYXJlbnRQcm9wZXJ0eT1udWxsXVxuICogQHByb3BlcnR5IHtKU09OUGF0aENhbGxiYWNrfSBbY2FsbGJhY2tdXG4gKiBAcHJvcGVydHkge090aGVyVHlwZUNhbGxiYWNrfSBbb3RoZXJUeXBlQ2FsbGJhY2tdIERlZmF1bHRzIHRvXG4gKiAgIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBvbiBlbmNvdW50ZXJpbmcgYEBvdGhlcmBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F1dG9zdGFydD10cnVlXVxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAtLSBDYW4gbWFrZSBtdWx0aWxpbmUgdHlwZSBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vc3lhdm9yc2t5L2NvbW1lbnQtcGFyc2VyL2lzc3Vlcy8xMDkgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xKU09OUGF0aE9wdGlvbnN9IG9wdHMgSWYgYSBzdHJpbmcsIHdpbGwgYmUgdHJlYXRlZCBhcyBgZXhwcmBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwcl0gSlNPTiBwYXRoIHRvIGV2YWx1YXRlXG4gKiBAcGFyYW0ge0pTT059IFtvYmpdIEpTT04gb2JqZWN0IHRvIGV2YWx1YXRlIGFnYWluc3RcbiAqIEBwYXJhbSB7SlNPTlBhdGhDYWxsYmFja30gW2NhbGxiYWNrXSBQYXNzZWQgMyBhcmd1bWVudHM6IDEpIGRlc2lyZWQgcGF5bG9hZFxuICogICAgIHBlciBgcmVzdWx0VHlwZWAsIDIpIGBcInZhbHVlXCJ8XCJwcm9wZXJ0eVwiYCwgMykgRnVsbCByZXR1cm5lZCBvYmplY3Qgd2l0aFxuICogICAgIGFsbCBwYXlsb2Fkc1xuICogQHBhcmFtIHtPdGhlclR5cGVDYWxsYmFja30gW290aGVyVHlwZUNhbGxiYWNrXSBJZiBgQG90aGVyKClgIGlzIGF0IHRoZSBlbmRcbiAqICAgb2Ygb25lJ3MgcXVlcnksIHRoaXMgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBpdGVtLCBpdHNcbiAqICAgcGF0aCwgaXRzIHBhcmVudCwgYW5kIGl0cyBwYXJlbnQncyBwcm9wZXJ0eSBuYW1lLCBhbmQgaXQgc2hvdWxkIHJldHVyblxuICogICBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdXBwbGllZCB2YWx1ZSBiZWxvbmdzIHRvIHRoZSBcIm90aGVyXCJcbiAqICAgdHlwZSBvciBub3QgKG9yIGl0IG1heSBoYW5kbGUgdHJhbnNmb3JtYXRpb25zIGFuZCByZXR1cm4gYGZhbHNlYCkuXG4gKiBAcmV0dXJucyB7SlNPTlBhdGh9XG4gKiBAY2xhc3NcbiAqL1xuXG5cbmZ1bmN0aW9uIEpTT05QYXRoKG9wdHMsIGV4cHIsIG9iaiwgY2FsbGJhY2ssIG90aGVyVHlwZUNhbGxiYWNrKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSlNPTlBhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgSlNPTlBhdGgob3B0cywgZXhwciwgb2JqLCBjYWxsYmFjaywgb3RoZXJUeXBlQ2FsbGJhY2spO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghZS5hdm9pZE5ldykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3RoZXJUeXBlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IG9iajtcbiAgICBvYmogPSBleHByO1xuICAgIGV4cHIgPSBvcHRzO1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG5cbiAgY29uc3Qgb3B0T2JqID0gb3B0cyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCc7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLmpzb24gPSBvcHRzLmpzb24gfHwgb2JqO1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGggfHwgZXhwcjtcbiAgdGhpcy5yZXN1bHRUeXBlID0gb3B0cy5yZXN1bHRUeXBlIHx8ICd2YWx1ZSc7XG4gIHRoaXMuZmxhdHRlbiA9IG9wdHMuZmxhdHRlbiB8fCBmYWxzZTtcbiAgdGhpcy53cmFwID0gaGFzT3duUHJvcC5jYWxsKG9wdHMsICd3cmFwJykgPyBvcHRzLndyYXAgOiB0cnVlO1xuICB0aGlzLnNhbmRib3ggPSBvcHRzLnNhbmRib3ggfHwge307XG4gIHRoaXMucHJldmVudEV2YWwgPSBvcHRzLnByZXZlbnRFdmFsIHx8IGZhbHNlO1xuICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50IHx8IG51bGw7XG4gIHRoaXMucGFyZW50UHJvcGVydHkgPSBvcHRzLnBhcmVudFByb3BlcnR5IHx8IG51bGw7XG4gIHRoaXMuY2FsbGJhY2sgPSBvcHRzLmNhbGxiYWNrIHx8IGNhbGxiYWNrIHx8IG51bGw7XG5cbiAgdGhpcy5vdGhlclR5cGVDYWxsYmFjayA9IG9wdHMub3RoZXJUeXBlQ2FsbGJhY2sgfHwgb3RoZXJUeXBlQ2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBvdGhlclR5cGVDYWxsYmFjayBjYWxsYmFjayBvcHRpb24gJyArICd3aXRoIHRoZSBAb3RoZXIoKSBvcGVyYXRvci4nKTtcbiAgfTtcblxuICBpZiAob3B0cy5hdXRvc3RhcnQgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIHBhdGg6IG9wdE9iaiA/IG9wdHMucGF0aCA6IGV4cHJcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRPYmopIHtcbiAgICAgIGFyZ3MuanNvbiA9IG9iajtcbiAgICB9IGVsc2UgaWYgKCdqc29uJyBpbiBvcHRzKSB7XG4gICAgICBhcmdzLmpzb24gPSBvcHRzLmpzb247XG4gICAgfVxuXG4gICAgY29uc3QgcmV0ID0gdGhpcy5ldmFsdWF0ZShhcmdzKTtcblxuICAgIGlmICghcmV0IHx8IHR5cGVvZiByZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgTmV3RXJyb3IocmV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59IC8vIFBVQkxJQyBNRVRIT0RTXG5cblxuSlNPTlBhdGgucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKGV4cHIsIGpzb24sIGNhbGxiYWNrLCBvdGhlclR5cGVDYWxsYmFjaykge1xuICBsZXQgY3VyclBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgY3VyclBhcmVudFByb3BlcnR5ID0gdGhpcy5wYXJlbnRQcm9wZXJ0eTtcbiAgbGV0IHtcbiAgICBmbGF0dGVuLFxuICAgIHdyYXBcbiAgfSA9IHRoaXM7XG4gIHRoaXMuY3VyclJlc3VsdFR5cGUgPSB0aGlzLnJlc3VsdFR5cGU7XG4gIHRoaXMuY3VyclByZXZlbnRFdmFsID0gdGhpcy5wcmV2ZW50RXZhbDtcbiAgdGhpcy5jdXJyU2FuZGJveCA9IHRoaXMuc2FuZGJveDtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCB0aGlzLmNhbGxiYWNrO1xuICB0aGlzLmN1cnJPdGhlclR5cGVDYWxsYmFjayA9IG90aGVyVHlwZUNhbGxiYWNrIHx8IHRoaXMub3RoZXJUeXBlQ2FsbGJhY2s7XG4gIGpzb24gPSBqc29uIHx8IHRoaXMuanNvbjtcbiAgZXhwciA9IGV4cHIgfHwgdGhpcy5wYXRoO1xuXG4gIGlmIChleHByICYmIHR5cGVvZiBleHByID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShleHByKSkge1xuICAgIGlmICghZXhwci5wYXRoICYmIGV4cHIucGF0aCAhPT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIFwicGF0aFwiIHByb3BlcnR5IHdoZW4gcHJvdmlkaW5nIGFuIG9iamVjdCAnICsgJ2FyZ3VtZW50IHRvIEpTT05QYXRoLmV2YWx1YXRlKCkuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ2pzb24nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgXCJqc29uXCIgcHJvcGVydHkgd2hlbiBwcm92aWRpbmcgYW4gb2JqZWN0ICcgKyAnYXJndW1lbnQgdG8gSlNPTlBhdGguZXZhbHVhdGUoKS4nKTtcbiAgICB9XG5cbiAgICAoe1xuICAgICAganNvblxuICAgIH0gPSBleHByKTtcbiAgICBmbGF0dGVuID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdmbGF0dGVuJykgPyBleHByLmZsYXR0ZW4gOiBmbGF0dGVuO1xuICAgIHRoaXMuY3VyclJlc3VsdFR5cGUgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3Jlc3VsdFR5cGUnKSA/IGV4cHIucmVzdWx0VHlwZSA6IHRoaXMuY3VyclJlc3VsdFR5cGU7XG4gICAgdGhpcy5jdXJyU2FuZGJveCA9IGhhc093blByb3AuY2FsbChleHByLCAnc2FuZGJveCcpID8gZXhwci5zYW5kYm94IDogdGhpcy5jdXJyU2FuZGJveDtcbiAgICB3cmFwID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICd3cmFwJykgPyBleHByLndyYXAgOiB3cmFwO1xuICAgIHRoaXMuY3VyclByZXZlbnRFdmFsID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdwcmV2ZW50RXZhbCcpID8gZXhwci5wcmV2ZW50RXZhbCA6IHRoaXMuY3VyclByZXZlbnRFdmFsO1xuICAgIGNhbGxiYWNrID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdjYWxsYmFjaycpID8gZXhwci5jYWxsYmFjayA6IGNhbGxiYWNrO1xuICAgIHRoaXMuY3Vyck90aGVyVHlwZUNhbGxiYWNrID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdvdGhlclR5cGVDYWxsYmFjaycpID8gZXhwci5vdGhlclR5cGVDYWxsYmFjayA6IHRoaXMuY3Vyck90aGVyVHlwZUNhbGxiYWNrO1xuICAgIGN1cnJQYXJlbnQgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3BhcmVudCcpID8gZXhwci5wYXJlbnQgOiBjdXJyUGFyZW50O1xuICAgIGN1cnJQYXJlbnRQcm9wZXJ0eSA9IGhhc093blByb3AuY2FsbChleHByLCAncGFyZW50UHJvcGVydHknKSA/IGV4cHIucGFyZW50UHJvcGVydHkgOiBjdXJyUGFyZW50UHJvcGVydHk7XG4gICAgZXhwciA9IGV4cHIucGF0aDtcbiAgfVxuXG4gIGN1cnJQYXJlbnQgPSBjdXJyUGFyZW50IHx8IG51bGw7XG4gIGN1cnJQYXJlbnRQcm9wZXJ0eSA9IGN1cnJQYXJlbnRQcm9wZXJ0eSB8fCBudWxsO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgZXhwciA9IEpTT05QYXRoLnRvUGF0aFN0cmluZyhleHByKTtcbiAgfVxuXG4gIGlmICghZXhwciAmJiBleHByICE9PSAnJyB8fCAhanNvbikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBleHByTGlzdCA9IEpTT05QYXRoLnRvUGF0aEFycmF5KGV4cHIpO1xuXG4gIGlmIChleHByTGlzdFswXSA9PT0gJyQnICYmIGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICBleHByTGlzdC5zaGlmdCgpO1xuICB9XG5cbiAgdGhpcy5faGFzUGFyZW50U2VsZWN0b3IgPSBudWxsO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3RyYWNlKGV4cHJMaXN0LCBqc29uLCBbJyQnXSwgY3VyclBhcmVudCwgY3VyclBhcmVudFByb3BlcnR5LCBjYWxsYmFjaykuZmlsdGVyKGZ1bmN0aW9uIChlYSkge1xuICAgIHJldHVybiBlYSAmJiAhZWEuaXNQYXJlbnRTZWxlY3RvcjtcbiAgfSk7XG5cbiAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHdyYXAgPyBbXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghd3JhcCAmJiByZXN1bHQubGVuZ3RoID09PSAxICYmICFyZXN1bHRbMF0uaGFzQXJyRXhwcikge1xuICAgIHJldHVybiB0aGlzLl9nZXRQcmVmZXJyZWRPdXRwdXQocmVzdWx0WzBdKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQucmVkdWNlKChyc2x0LCBlYSkgPT4ge1xuICAgIGNvbnN0IHZhbE9yUGF0aCA9IHRoaXMuX2dldFByZWZlcnJlZE91dHB1dChlYSk7XG5cbiAgICBpZiAoZmxhdHRlbiAmJiBBcnJheS5pc0FycmF5KHZhbE9yUGF0aCkpIHtcbiAgICAgIHJzbHQgPSByc2x0LmNvbmNhdCh2YWxPclBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByc2x0LnB1c2godmFsT3JQYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnNsdDtcbiAgfSwgW10pO1xufTsgLy8gUFJJVkFURSBNRVRIT0RTXG5cblxuSlNPTlBhdGgucHJvdG90eXBlLl9nZXRQcmVmZXJyZWRPdXRwdXQgPSBmdW5jdGlvbiAoZWEpIHtcbiAgY29uc3QgcmVzdWx0VHlwZSA9IHRoaXMuY3VyclJlc3VsdFR5cGU7XG5cbiAgc3dpdGNoIChyZXN1bHRUeXBlKSB7XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IEFycmF5LmlzQXJyYXkoZWEucGF0aCkgPyBlYS5wYXRoIDogSlNPTlBhdGgudG9QYXRoQXJyYXkoZWEucGF0aCk7XG4gICAgICAgIGVhLnBvaW50ZXIgPSBKU09OUGF0aC50b1BvaW50ZXIocGF0aCk7XG4gICAgICAgIGVhLnBhdGggPSB0eXBlb2YgZWEucGF0aCA9PT0gJ3N0cmluZycgPyBlYS5wYXRoIDogSlNPTlBhdGgudG9QYXRoU3RyaW5nKGVhLnBhdGgpO1xuICAgICAgICByZXR1cm4gZWE7XG4gICAgICB9XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgY2FzZSAncGFyZW50JzpcbiAgICBjYXNlICdwYXJlbnRQcm9wZXJ0eSc6XG4gICAgICByZXR1cm4gZWFbcmVzdWx0VHlwZV07XG5cbiAgICBjYXNlICdwYXRoJzpcbiAgICAgIHJldHVybiBKU09OUGF0aC50b1BhdGhTdHJpbmcoZWFbcmVzdWx0VHlwZV0pO1xuXG4gICAgY2FzZSAncG9pbnRlcic6XG4gICAgICByZXR1cm4gSlNPTlBhdGgudG9Qb2ludGVyKGVhLnBhdGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gcmVzdWx0IHR5cGUnKTtcbiAgfVxufTtcblxuSlNPTlBhdGgucHJvdG90eXBlLl9oYW5kbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChmdWxsUmV0T2JqLCBjYWxsYmFjaywgdHlwZSkge1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcmVmZXJyZWRPdXRwdXQgPSB0aGlzLl9nZXRQcmVmZXJyZWRPdXRwdXQoZnVsbFJldE9iaik7XG5cbiAgICBmdWxsUmV0T2JqLnBhdGggPSB0eXBlb2YgZnVsbFJldE9iai5wYXRoID09PSAnc3RyaW5nJyA/IGZ1bGxSZXRPYmoucGF0aCA6IEpTT05QYXRoLnRvUGF0aFN0cmluZyhmdWxsUmV0T2JqLnBhdGgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cblxuICAgIGNhbGxiYWNrKHByZWZlcnJlZE91dHB1dCwgdHlwZSwgZnVsbFJldE9iaik7XG4gIH1cbn07XG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwclxuICogQHBhcmFtIHtKU09OT2JqZWN0fSB2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1BsYWluT2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50UHJvcE5hbWVcbiAqIEBwYXJhbSB7SlNPTlBhdGhDYWxsYmFja30gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQXJyRXhwclxuICogQHBhcmFtIHtib29sZWFufSBsaXRlcmFsUHJpb3JpdHlcbiAqIEByZXR1cm5zIHtSZXR1cm5PYmplY3R8UmV0dXJuT2JqZWN0W119XG4gKi9cblxuXG5KU09OUGF0aC5wcm90b3R5cGUuX3RyYWNlID0gZnVuY3Rpb24gKGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGhhc0FyckV4cHIsIGxpdGVyYWxQcmlvcml0eSkge1xuICAvLyBObyBleHByIHRvIGZvbGxvdz8gcmV0dXJuIHBhdGggYW5kIHZhbHVlIGFzIHRoZSByZXN1bHQgb2ZcbiAgLy8gIHRoaXMgdHJhY2UgYnJhbmNoXG4gIGxldCByZXRPYmo7XG5cbiAgaWYgKCFleHByLmxlbmd0aCkge1xuICAgIHJldE9iaiA9IHtcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogdmFsLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50UHJvcGVydHk6IHBhcmVudFByb3BOYW1lLFxuICAgICAgaGFzQXJyRXhwclxuICAgIH07XG5cbiAgICB0aGlzLl9oYW5kbGVDYWxsYmFjayhyZXRPYmosIGNhbGxiYWNrLCAndmFsdWUnKTtcblxuICAgIHJldHVybiByZXRPYmo7XG4gIH1cblxuICBjb25zdCBsb2MgPSBleHByWzBdLFxuICAgICAgICB4ID0gZXhwci5zbGljZSgxKTsgLy8gV2UgbmVlZCB0byBnYXRoZXIgdGhlIHJldHVybiB2YWx1ZSBvZiByZWN1cnNpdmUgdHJhY2UgY2FsbHMgaW4gb3JkZXIgdG9cbiAgLy8gZG8gdGhlIHBhcmVudCBzZWwgY29tcHV0YXRpb24uXG5cbiAgY29uc3QgcmV0ID0gW107XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1JldHVybk9iamVjdHxSZXR1cm5PYmplY3RbXX0gZWxlbXNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZFJldChlbGVtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1zKSkge1xuICAgICAgLy8gVGhpcyB3YXMgY2F1c2luZyBleGNlc3NpdmUgc3RhY2sgc2l6ZSBpbiBOb2RlICh3aXRoIG9yXG4gICAgICAvLyAgd2l0aG91dCBCYWJlbCkgYWdhaW5zdCBvdXIgcGVyZm9ybWFuY2UgdGVzdDpcbiAgICAgIC8vICBgcmV0LnB1c2goLi4uZWxlbXMpO2BcbiAgICAgIGVsZW1zLmZvckVhY2godCA9PiB7XG4gICAgICAgIHJldC5wdXNoKHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGVsZW1zKTtcbiAgICB9XG4gIH1cblxuICBpZiAoKHR5cGVvZiBsb2MgIT09ICdzdHJpbmcnIHx8IGxpdGVyYWxQcmlvcml0eSkgJiYgdmFsICYmIGhhc093blByb3AuY2FsbCh2YWwsIGxvYykpIHtcbiAgICAvLyBzaW1wbGUgY2FzZS0tZGlyZWN0bHkgZm9sbG93IHByb3BlcnR5XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbFtsb2NdLCBwdXNoKHBhdGgsIGxvYyksIHZhbCwgbG9jLCBjYWxsYmFjaywgaGFzQXJyRXhwcikpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItc3dpdGNoIC0tIFBhcnQgb2YgbGFyZ2VyIGBpZmBcbiAgfSBlbHNlIGlmIChsb2MgPT09ICcqJykge1xuICAgIC8vIGFsbCBjaGlsZCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5fd2Fsayhsb2MsIHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIChtLCBsLCBfeCwgdiwgcCwgcGFyLCBwciwgY2IpID0+IHtcbiAgICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KG0sIF94KSwgdiwgcCwgcGFyLCBwciwgY2IsIHRydWUsIHRydWUpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsb2MgPT09ICcuLicpIHtcbiAgICAvLyBhbGwgZGVzY2VuZGVudCBwYXJlbnQgcHJvcGVydGllc1xuICAgIC8vIENoZWNrIHJlbWFpbmluZyBleHByZXNzaW9uIHdpdGggdmFsJ3MgaW1tZWRpYXRlIGNoaWxkcmVuXG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGhhc0FyckV4cHIpKTtcblxuICAgIHRoaXMuX3dhbGsobG9jLCB4LCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCAobSwgbCwgX3gsIHYsIHAsIHBhciwgcHIsIGNiKSA9PiB7XG4gICAgICAvLyBXZSBkb24ndCBqb2luIG0gYW5kIHggaGVyZSBiZWNhdXNlIHdlIG9ubHkgd2FudCBwYXJlbnRzLFxuICAgICAgLy8gICBub3Qgc2NhbGFyIHZhbHVlc1xuICAgICAgaWYgKHR5cGVvZiB2W21dID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBLZWVwIGdvaW5nIHdpdGggcmVjdXJzaXZlIGRlc2NlbnQgb24gdmFsJ3NcbiAgICAgICAgLy8gICBvYmplY3QgY2hpbGRyZW5cbiAgICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQobCwgX3gpLCB2W21dLCBwdXNoKHAsIG0pLCB2LCBtLCBjYiwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH0pOyAvLyBUaGUgcGFyZW50IHNlbCBjb21wdXRhdGlvbiBpcyBoYW5kbGVkIGluIHRoZSBmcmFtZSBhYm92ZSB1c2luZyB0aGVcbiAgICAvLyBhbmNlc3RvciBvYmplY3Qgb2YgdmFsXG5cbiAgfSBlbHNlIGlmIChsb2MgPT09ICdeJykge1xuICAgIC8vIFRoaXMgaXMgbm90IGEgZmluYWwgZW5kcG9pbnQsIHNvIHdlIGRvIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIGhlcmVcbiAgICB0aGlzLl9oYXNQYXJlbnRTZWxlY3RvciA9IHRydWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgZXhwcjogeCxcbiAgICAgIGlzUGFyZW50U2VsZWN0b3I6IHRydWVcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxvYyA9PT0gJ34nKSB7XG4gICAgLy8gcHJvcGVydHkgbmFtZVxuICAgIHJldE9iaiA9IHtcbiAgICAgIHBhdGg6IHB1c2gocGF0aCwgbG9jKSxcbiAgICAgIHZhbHVlOiBwYXJlbnRQcm9wTmFtZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudFByb3BlcnR5OiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuX2hhbmRsZUNhbGxiYWNrKHJldE9iaiwgY2FsbGJhY2ssICdwcm9wZXJ0eScpO1xuXG4gICAgcmV0dXJuIHJldE9iajtcbiAgfSBlbHNlIGlmIChsb2MgPT09ICckJykge1xuICAgIC8vIHJvb3Qgb25seVxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWwsIHBhdGgsIG51bGwsIG51bGwsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7XG4gIH0gZWxzZSBpZiAoL14oLT9cXGQqKTooLT9cXGQqKTo/KFxcZCopJC91LnRlc3QobG9jKSkge1xuICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gIFB5dGhvbiBzbGljZSBzeW50YXhcbiAgICBhZGRSZXQodGhpcy5fc2xpY2UobG9jLCB4LCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrKSk7XG4gIH0gZWxzZSBpZiAobG9jLmluZGV4T2YoJz8oJykgPT09IDApIHtcbiAgICAvLyBbPyhleHByKV0gKGZpbHRlcmluZylcbiAgICBpZiAodGhpcy5jdXJyUHJldmVudEV2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZhbCBbPyhleHByKV0gcHJldmVudGVkIGluIEpTT05QYXRoIGV4cHJlc3Npb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2Fsayhsb2MsIHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIChtLCBsLCBfeCwgdiwgcCwgcGFyLCBwciwgY2IpID0+IHtcbiAgICAgIGlmICh0aGlzLl9ldmFsKGwucmVwbGFjZSgvXlxcP1xcKCguKj8pXFwpJC91LCAnJDEnKSwgdlttXSwgbSwgcCwgcGFyLCBwcikpIHtcbiAgICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQobSwgX3gpLCB2LCBwLCBwYXIsIHByLCBjYiwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxvY1swXSA9PT0gJygnKSB7XG4gICAgLy8gWyhleHByKV0gKGR5bmFtaWMgcHJvcGVydHkvaW5kZXgpXG4gICAgaWYgKHRoaXMuY3VyclByZXZlbnRFdmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2YWwgWyhleHByKV0gcHJldmVudGVkIGluIEpTT05QYXRoIGV4cHJlc3Npb24uJyk7XG4gICAgfSAvLyBBcyB0aGlzIHdpbGwgcmVzb2x2ZSB0byBhIHByb3BlcnR5IG5hbWUgKGJ1dCB3ZSBkb24ndCBrbm93IGl0XG4gICAgLy8gIHlldCksIHByb3BlcnR5IGFuZCBwYXJlbnQgaW5mb3JtYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgLy8gIHBhcmVudCBvZiB0aGUgcHJvcGVydHkgdG8gd2hpY2ggdGhpcyBleHByZXNzaW9uIHdpbGwgcmVzb2x2ZVxuXG5cbiAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdCh0aGlzLl9ldmFsKGxvYywgdmFsLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGguc2xpY2UoMCwgLTEpLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lKSwgeCksIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGhhc0FyckV4cHIpKTtcbiAgfSBlbHNlIGlmIChsb2NbMF0gPT09ICdAJykge1xuICAgIC8vIHZhbHVlIHR5cGU6IEBib29sZWFuKCksIGV0Yy5cbiAgICBsZXQgYWRkVHlwZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IGxvYy5zbGljZSgxLCAtMik7XG5cbiAgICBzd2l0Y2ggKHZhbHVlVHlwZSkge1xuICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgaWYgKCF2YWwgfHwgIVsnb2JqZWN0JywgJ2Z1bmN0aW9uJ10uaW5jbHVkZXModHlwZW9mIHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSB2YWx1ZVR5cGUpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWwpICYmICEodmFsICUgMSkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdub25GaW5pdGUnOlxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09IHZhbHVlVHlwZSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ290aGVyJzpcbiAgICAgICAgYWRkVHlwZSA9IHRoaXMuY3Vyck90aGVyVHlwZUNhbGxiYWNrKHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gdmFsdWUgdHlwZSAnICsgdmFsdWVUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAoYWRkVHlwZSkge1xuICAgICAgcmV0T2JqID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHBhcmVudFByb3BlcnR5OiBwYXJlbnRQcm9wTmFtZVxuICAgICAgfTtcblxuICAgICAgdGhpcy5faGFuZGxlQ2FsbGJhY2socmV0T2JqLCBjYWxsYmFjaywgJ3ZhbHVlJyk7XG5cbiAgICAgIHJldHVybiByZXRPYmo7XG4gICAgfSAvLyBgLWVzY2FwZWQgcHJvcGVydHlcblxuICB9IGVsc2UgaWYgKGxvY1swXSA9PT0gJ2AnICYmIHZhbCAmJiBoYXNPd25Qcm9wLmNhbGwodmFsLCBsb2Muc2xpY2UoMSkpKSB7XG4gICAgY29uc3QgbG9jUHJvcCA9IGxvYy5zbGljZSgxKTtcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW2xvY1Byb3BdLCBwdXNoKHBhdGgsIGxvY1Byb3ApLCB2YWwsIGxvY1Byb3AsIGNhbGxiYWNrLCBoYXNBcnJFeHByLCB0cnVlKSk7XG4gIH0gZWxzZSBpZiAobG9jLmluY2x1ZGVzKCcsJykpIHtcbiAgICAvLyBbbmFtZTEsbmFtZTIsLi4uXVxuICAgIGNvbnN0IHBhcnRzID0gbG9jLnNwbGl0KCcsJyk7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KHBhcnQsIHgpLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCB0cnVlKSk7XG4gICAgfSAvLyBzaW1wbGUgY2FzZS0tZGlyZWN0bHkgZm9sbG93IHByb3BlcnR5XG5cbiAgfSBlbHNlIGlmICghbGl0ZXJhbFByaW9yaXR5ICYmIHZhbCAmJiBoYXNPd25Qcm9wLmNhbGwodmFsLCBsb2MpKSB7XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbFtsb2NdLCBwdXNoKHBhdGgsIGxvYyksIHZhbCwgbG9jLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgdHJ1ZSkpO1xuICB9IC8vIFdlIGNoZWNrIHRoZSByZXN1bHRpbmcgdmFsdWVzIGZvciBwYXJlbnQgc2VsZWN0aW9ucy4gRm9yIHBhcmVudFxuICAvLyBzZWxlY3Rpb25zIHdlIGRpc2NhcmQgdGhlIHZhbHVlIG9iamVjdCBhbmQgY29udGludWUgdGhlIHRyYWNlIHdpdGggdGhlXG4gIC8vIGN1cnJlbnQgdmFsIG9iamVjdFxuXG5cbiAgaWYgKHRoaXMuX2hhc1BhcmVudFNlbGVjdG9yKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCByZXQubGVuZ3RoOyB0KyspIHtcbiAgICAgIGNvbnN0IHJldHQgPSByZXRbdF07XG5cbiAgICAgIGlmIChyZXR0ICYmIHJldHQuaXNQYXJlbnRTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLl90cmFjZShyZXR0LmV4cHIsIHZhbCwgcmV0dC5wYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwcik7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG1wKSkge1xuICAgICAgICAgIHJldFt0XSA9IHRtcFswXTtcbiAgICAgICAgICBjb25zdCB0bCA9IHRtcC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGxldCB0dCA9IDE7IHR0IDwgdGw7IHR0KyspIHtcbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIHJldC5zcGxpY2UodCwgMCwgdG1wW3R0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldFt0XSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX3dhbGsgPSBmdW5jdGlvbiAobG9jLCBleHByLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBmKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjb25zdCBuID0gdmFsLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBmKGksIGxvYywgZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5rZXlzKHZhbCkuZm9yRWFjaChtID0+IHtcbiAgICAgIGYobSwgbG9jLCBleHByLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxufTtcblxuSlNPTlBhdGgucHJvdG90eXBlLl9zbGljZSA9IGZ1bmN0aW9uIChsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbGVuID0gdmFsLmxlbmd0aCxcbiAgICAgICAgcGFydHMgPSBsb2Muc3BsaXQoJzonKSxcbiAgICAgICAgc3RlcCA9IHBhcnRzWzJdICYmIE51bWJlci5wYXJzZUludChwYXJ0c1syXSkgfHwgMTtcbiAgbGV0IHN0YXJ0ID0gcGFydHNbMF0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzBdKSB8fCAwLFxuICAgICAgZW5kID0gcGFydHNbMV0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzFdKSB8fCBsZW47XG4gIHN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoMCwgc3RhcnQgKyBsZW4pIDogTWF0aC5taW4obGVuLCBzdGFydCk7XG4gIGVuZCA9IGVuZCA8IDAgPyBNYXRoLm1heCgwLCBlbmQgKyBsZW4pIDogTWF0aC5taW4obGVuLCBlbmQpO1xuICBjb25zdCByZXQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gc3RlcCkge1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuX3RyYWNlKHVuc2hpZnQoaSwgZXhwciksIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIHRydWUpOyAvLyBTaG91bGQgb25seSBiZSBwb3NzaWJsZSB0byBiZSBhbiBhcnJheSBoZXJlIHNpbmNlIGZpcnN0IHBhcnQgb2ZcbiAgICAvLyAgIGBgdW5zaGlmdChpLCBleHByKWAgcGFzc2VkIGluIGFib3ZlIHdvdWxkIG5vdCBiZSBlbXB0eSwgbm9yIGB+YCxcbiAgICAvLyAgICAgbm9yIGJlZ2luIHdpdGggYEBgIChhcyBjb3VsZCByZXR1cm4gb2JqZWN0cylcbiAgICAvLyBUaGlzIHdhcyBjYXVzaW5nIGV4Y2Vzc2l2ZSBzdGFjayBzaXplIGluIE5vZGUgKHdpdGggb3JcbiAgICAvLyAgd2l0aG91dCBCYWJlbCkgYWdhaW5zdCBvdXIgcGVyZm9ybWFuY2UgdGVzdDogYHJldC5wdXNoKC4uLnRtcCk7YFxuXG5cbiAgICB0bXAuZm9yRWFjaCh0ID0+IHtcbiAgICAgIHJldC5wdXNoKHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS5fZXZhbCA9IGZ1bmN0aW9uIChjb2RlLCBfdiwgX3ZuYW1lLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lKSB7XG4gIGlmIChjb2RlLmluY2x1ZGVzKCdAcGFyZW50UHJvcGVydHknKSkge1xuICAgIHRoaXMuY3VyclNhbmRib3guXyRfcGFyZW50UHJvcGVydHkgPSBwYXJlbnRQcm9wTmFtZTtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AcGFyZW50UHJvcGVydHkvZ3UsICdfJF9wYXJlbnRQcm9wZXJ0eScpO1xuICB9XG5cbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0BwYXJlbnQnKSkge1xuICAgIHRoaXMuY3VyclNhbmRib3guXyRfcGFyZW50ID0gcGFyZW50O1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0BwYXJlbnQvZ3UsICdfJF9wYXJlbnQnKTtcbiAgfVxuXG4gIGlmIChjb2RlLmluY2x1ZGVzKCdAcHJvcGVydHknKSkge1xuICAgIHRoaXMuY3VyclNhbmRib3guXyRfcHJvcGVydHkgPSBfdm5hbWU7XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQHByb3BlcnR5L2d1LCAnXyRfcHJvcGVydHknKTtcbiAgfVxuXG4gIGlmIChjb2RlLmluY2x1ZGVzKCdAcGF0aCcpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wYXRoID0gSlNPTlBhdGgudG9QYXRoU3RyaW5nKHBhdGguY29uY2F0KFtfdm5hbWVdKSk7XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQHBhdGgvZ3UsICdfJF9wYXRoJyk7XG4gIH1cblxuICBpZiAoY29kZS5pbmNsdWRlcygnQHJvb3QnKSkge1xuICAgIHRoaXMuY3VyclNhbmRib3guXyRfcm9vdCA9IHRoaXMuanNvbjtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9Acm9vdC9ndSwgJ18kX3Jvb3QnKTtcbiAgfVxuXG4gIGlmICgvQChbLlxccylbXSkvdS50ZXN0KGNvZGUpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF92ID0gX3Y7XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQChbLlxccylbXSkvZ3UsICdfJF92JDEnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMudm0ucnVuSW5OZXdDb250ZXh0KGNvZGUsIHRoaXMuY3VyclNhbmRib3gpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2pzb25QYXRoOiAnICsgZS5tZXNzYWdlICsgJzogJyArIGNvZGUpO1xuICB9XG59OyAvLyBQVUJMSUMgQ0xBU1MgUFJPUEVSVElFUyBBTkQgTUVUSE9EU1xuLy8gQ291bGQgc3RvcmUgdGhlIGNhY2hlIG9iamVjdCBpdHNlbGZcblxuXG5KU09OUGF0aC5jYWNoZSA9IHt9O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoQXJyIEFycmF5IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHN0cmluZ1xuICovXG5cbkpTT05QYXRoLnRvUGF0aFN0cmluZyA9IGZ1bmN0aW9uIChwYXRoQXJyKSB7XG4gIGNvbnN0IHggPSBwYXRoQXJyLFxuICAgICAgICBuID0geC5sZW5ndGg7XG4gIGxldCBwID0gJyQnO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKCEvXih+fFxcXnxALio/XFwoXFwpKSQvdS50ZXN0KHhbaV0pKSB7XG4gICAgICBwICs9IC9eWzAtOSpdKyQvdS50ZXN0KHhbaV0pID8gJ1snICsgeFtpXSArICddJyA6IFwiWydcIiArIHhbaV0gKyBcIiddXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHA7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlciBKU09OIFBhdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEpTT04gUG9pbnRlclxuICovXG5cblxuSlNPTlBhdGgudG9Qb2ludGVyID0gZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgY29uc3QgeCA9IHBvaW50ZXIsXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcbiAgbGV0IHAgPSAnJztcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgIGlmICghL14ofnxcXF58QC4qP1xcKFxcKSkkL3UudGVzdCh4W2ldKSkge1xuICAgICAgcCArPSAnLycgKyB4W2ldLnRvU3RyaW5nKCkucmVwbGFjZSgvfi9ndSwgJ34wJykucmVwbGFjZSgvXFwvL2d1LCAnfjEnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcDtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByIEV4cHJlc3Npb24gdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5cblxuSlNPTlBhdGgudG9QYXRoQXJyYXkgPSBmdW5jdGlvbiAoZXhwcikge1xuICBjb25zdCB7XG4gICAgY2FjaGVcbiAgfSA9IEpTT05QYXRoO1xuXG4gIGlmIChjYWNoZVtleHByXSkge1xuICAgIHJldHVybiBjYWNoZVtleHByXS5jb25jYXQoKTtcbiAgfVxuXG4gIGNvbnN0IHN1YnggPSBbXTtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGV4cHIgLy8gUHJvcGVydGllc1xuICAucmVwbGFjZSgvQCg/Om51bGx8Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfGludGVnZXJ8dW5kZWZpbmVkfG5vbkZpbml0ZXxzY2FsYXJ8YXJyYXl8b2JqZWN0fGZ1bmN0aW9ufG90aGVyKVxcKFxcKS9ndSwgJzskJjsnKSAvLyBQYXJlbnRoZXRpY2FsIGV2YWx1YXRpb25zIChmaWx0ZXJpbmcgYW5kIG90aGVyd2lzZSksIGRpcmVjdGx5XG4gIC8vICAgd2l0aGluIGJyYWNrZXRzIG9yIHNpbmdsZSBxdW90ZXNcbiAgLnJlcGxhY2UoL1tbJ10oXFw/P1xcKC4qP1xcKSlbXFxdJ10vZ3UsIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICByZXR1cm4gJ1sjJyArIChzdWJ4LnB1c2goJDEpIC0gMSkgKyAnXSc7XG4gIH0pIC8vIEVzY2FwZSBwZXJpb2RzIGFuZCB0aWxkZXMgd2l0aGluIHByb3BlcnRpZXNcbiAgLnJlcGxhY2UoL1xcW1snXCJdKFteJ1xcXV0qKVsnXCJdXFxdL2d1LCBmdW5jdGlvbiAoJDAsIHByb3ApIHtcbiAgICByZXR1cm4gXCJbJ1wiICsgcHJvcC5yZXBsYWNlKC9cXC4vZ3UsICclQCUnKS5yZXBsYWNlKC9+L2d1LCAnJSVAQCUlJykgKyBcIiddXCI7XG4gIH0pIC8vIFByb3BlcnRpZXMgb3BlcmF0b3JcbiAgLnJlcGxhY2UoL34vZ3UsICc7fjsnKSAvLyBTcGxpdCBieSBwcm9wZXJ0eSBib3VuZGFyaWVzXG4gIC5yZXBsYWNlKC9bJ1wiXT9cXC5bJ1wiXT8oPyFbXltdKlxcXSl8XFxbWydcIl0/L2d1LCAnOycpIC8vIFJlaW5zZXJ0IHBlcmlvZHMgd2l0aGluIHByb3BlcnRpZXNcbiAgLnJlcGxhY2UoLyVAJS9ndSwgJy4nKSAvLyBSZWluc2VydCB0aWxkZXMgd2l0aGluIHByb3BlcnRpZXNcbiAgLnJlcGxhY2UoLyUlQEAlJS9ndSwgJ34nKSAvLyBQYXJlbnRcbiAgLnJlcGxhY2UoLyg/OjspPyhcXF4rKSg/OjspPy9ndSwgZnVuY3Rpb24gKCQwLCB1cHMpIHtcbiAgICByZXR1cm4gJzsnICsgdXBzLnNwbGl0KCcnKS5qb2luKCc7JykgKyAnOyc7XG4gIH0pIC8vIERlc2NlbmRlbnRzXG4gIC5yZXBsYWNlKC87Ozt8OzsvZ3UsICc7Li47JykgLy8gUmVtb3ZlIHRyYWlsaW5nXG4gIC5yZXBsYWNlKC87JHwnP1xcXXwnJC9ndSwgJycpO1xuICBjb25zdCBleHByTGlzdCA9IG5vcm1hbGl6ZWQuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKGV4cCkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhwLm1hdGNoKC8jKFxcZCspL3UpO1xuICAgIHJldHVybiAhbWF0Y2ggfHwgIW1hdGNoWzFdID8gZXhwIDogc3VieFttYXRjaFsxXV07XG4gIH0pO1xuICBjYWNoZVtleHByXSA9IGV4cHJMaXN0O1xuICByZXR1cm4gY2FjaGVbZXhwcl0uY29uY2F0KCk7XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUudm0gPSB2bV9fZGVmYXVsdFsnZGVmYXVsdCddO1xuXG5leHBvcnRzLkpTT05QYXRoID0gSlNPTlBhdGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonpath-plus/dist/index-node-cjs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsonpath-plus/dist/index-node-cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/jsonpath-plus/dist/index-node-cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar vm = __webpack_require__(/*! vm */ \"vm\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar vm__default = /*#__PURE__*/ _interopDefaultLegacy(vm);\nconst { hasOwnProperty: hasOwnProp } = Object.prototype;\n/**\n* @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject\n*/ /**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {any} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */ function push(arr, item) {\n    arr = arr.slice();\n    arr.push(item);\n    return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {any} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */ function unshift(item, arr) {\n    arr = arr.slice();\n    arr.unshift(item);\n    return arr;\n}\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */ class NewError extends Error {\n    /**\n   * @param {any} value The evaluated scalar value\n   */ constructor(value){\n        super('JSONPath should not be called with \"new\" (it prevents return ' + \"of (unwrapped) scalar values)\");\n        this.avoidNew = true;\n        this.value = value;\n        this.name = \"NewError\";\n    }\n}\n/**\n* @typedef {PlainObject} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {PlainObject|GenericArray} parent\n* @property {string} parentProperty\n*/ /**\n* @callback JSONPathCallback\n* @param {string|PlainObject} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/ /**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {PlainObject|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/ /* eslint-disable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */ /**\n * @typedef {PlainObject} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {PlainObject} [sandbox={}]\n * @property {boolean} [preventEval=false]\n * @property {PlainObject|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */ /* eslint-enable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */ /**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */ function JSONPath(opts, expr, obj, callback, otherTypeCallback) {\n    // eslint-disable-next-line no-restricted-syntax\n    if (!(this instanceof JSONPath)) {\n        try {\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n        } catch (e) {\n            if (!e.avoidNew) {\n                throw e;\n            }\n            return e.value;\n        }\n    }\n    if (typeof opts === \"string\") {\n        otherTypeCallback = callback;\n        callback = obj;\n        obj = expr;\n        expr = opts;\n        opts = null;\n    }\n    const optObj = opts && typeof opts === \"object\";\n    opts = opts || {};\n    this.json = opts.json || obj;\n    this.path = opts.path || expr;\n    this.resultType = opts.resultType || \"value\";\n    this.flatten = opts.flatten || false;\n    this.wrap = hasOwnProp.call(opts, \"wrap\") ? opts.wrap : true;\n    this.sandbox = opts.sandbox || {};\n    this.preventEval = opts.preventEval || false;\n    this.parent = opts.parent || null;\n    this.parentProperty = opts.parentProperty || null;\n    this.callback = opts.callback || callback || null;\n    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {\n        throw new TypeError(\"You must supply an otherTypeCallback callback option \" + \"with the @other() operator.\");\n    };\n    if (opts.autostart !== false) {\n        const args = {\n            path: optObj ? opts.path : expr\n        };\n        if (!optObj) {\n            args.json = obj;\n        } else if (\"json\" in opts) {\n            args.json = opts.json;\n        }\n        const ret = this.evaluate(args);\n        if (!ret || typeof ret !== \"object\") {\n            throw new NewError(ret);\n        }\n        return ret;\n    }\n} // PUBLIC METHODS\nJSONPath.prototype.evaluate = function(expr, json, callback, otherTypeCallback) {\n    let currParent = this.parent, currParentProperty = this.parentProperty;\n    let { flatten, wrap } = this;\n    this.currResultType = this.resultType;\n    this.currPreventEval = this.preventEval;\n    this.currSandbox = this.sandbox;\n    callback = callback || this.callback;\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n    json = json || this.json;\n    expr = expr || this.path;\n    if (expr && typeof expr === \"object\" && !Array.isArray(expr)) {\n        if (!expr.path && expr.path !== \"\") {\n            throw new TypeError('You must supply a \"path\" property when providing an object ' + \"argument to JSONPath.evaluate().\");\n        }\n        if (!hasOwnProp.call(expr, \"json\")) {\n            throw new TypeError('You must supply a \"json\" property when providing an object ' + \"argument to JSONPath.evaluate().\");\n        }\n        ({ json } = expr);\n        flatten = hasOwnProp.call(expr, \"flatten\") ? expr.flatten : flatten;\n        this.currResultType = hasOwnProp.call(expr, \"resultType\") ? expr.resultType : this.currResultType;\n        this.currSandbox = hasOwnProp.call(expr, \"sandbox\") ? expr.sandbox : this.currSandbox;\n        wrap = hasOwnProp.call(expr, \"wrap\") ? expr.wrap : wrap;\n        this.currPreventEval = hasOwnProp.call(expr, \"preventEval\") ? expr.preventEval : this.currPreventEval;\n        callback = hasOwnProp.call(expr, \"callback\") ? expr.callback : callback;\n        this.currOtherTypeCallback = hasOwnProp.call(expr, \"otherTypeCallback\") ? expr.otherTypeCallback : this.currOtherTypeCallback;\n        currParent = hasOwnProp.call(expr, \"parent\") ? expr.parent : currParent;\n        currParentProperty = hasOwnProp.call(expr, \"parentProperty\") ? expr.parentProperty : currParentProperty;\n        expr = expr.path;\n    }\n    currParent = currParent || null;\n    currParentProperty = currParentProperty || null;\n    if (Array.isArray(expr)) {\n        expr = JSONPath.toPathString(expr);\n    }\n    if (!expr && expr !== \"\" || !json) {\n        return undefined;\n    }\n    const exprList = JSONPath.toPathArray(expr);\n    if (exprList[0] === \"$\" && exprList.length > 1) {\n        exprList.shift();\n    }\n    this._hasParentSelector = null;\n    const result = this._trace(exprList, json, [\n        \"$\"\n    ], currParent, currParentProperty, callback).filter(function(ea) {\n        return ea && !ea.isParentSelector;\n    });\n    if (!result.length) {\n        return wrap ? [] : undefined;\n    }\n    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n        return this._getPreferredOutput(result[0]);\n    }\n    return result.reduce((rslt, ea)=>{\n        const valOrPath = this._getPreferredOutput(ea);\n        if (flatten && Array.isArray(valOrPath)) {\n            rslt = rslt.concat(valOrPath);\n        } else {\n            rslt.push(valOrPath);\n        }\n        return rslt;\n    }, []);\n}; // PRIVATE METHODS\nJSONPath.prototype._getPreferredOutput = function(ea) {\n    const resultType = this.currResultType;\n    switch(resultType){\n        case \"all\":\n            {\n                const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);\n                ea.pointer = JSONPath.toPointer(path);\n                ea.path = typeof ea.path === \"string\" ? ea.path : JSONPath.toPathString(ea.path);\n                return ea;\n            }\n        case \"value\":\n        case \"parent\":\n        case \"parentProperty\":\n            return ea[resultType];\n        case \"path\":\n            return JSONPath.toPathString(ea[resultType]);\n        case \"pointer\":\n            return JSONPath.toPointer(ea.path);\n        default:\n            throw new TypeError(\"Unknown result type\");\n    }\n};\nJSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {\n    if (callback) {\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\n        fullRetObj.path = typeof fullRetObj.path === \"string\" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path); // eslint-disable-next-line node/callback-return\n        callback(preferredOutput, type, fullRetObj);\n    }\n};\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {PlainObject|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */ JSONPath.prototype._trace = function(expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {\n    // No expr to follow? return path and value as the result of\n    //  this trace branch\n    let retObj;\n    if (!expr.length) {\n        retObj = {\n            path,\n            value: val,\n            parent,\n            parentProperty: parentPropName,\n            hasArrExpr\n        };\n        this._handleCallback(retObj, callback, \"value\");\n        return retObj;\n    }\n    const loc = expr[0], x = expr.slice(1); // We need to gather the return value of recursive trace calls in order to\n    // do the parent sel computation.\n    const ret = [];\n    /**\n   *\n   * @param {ReturnObject|ReturnObject[]} elems\n   * @returns {void}\n   */ function addRet(elems) {\n        if (Array.isArray(elems)) {\n            // This was causing excessive stack size in Node (with or\n            //  without Babel) against our performance test:\n            //  `ret.push(...elems);`\n            elems.forEach((t)=>{\n                ret.push(t);\n            });\n        } else {\n            ret.push(elems);\n        }\n    }\n    if ((typeof loc !== \"string\" || literalPriority) && val && hasOwnProp.call(val, loc)) {\n        // simple case--directly follow property\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr)); // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n    } else if (loc === \"*\") {\n        // all child properties\n        this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb)=>{\n            addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true, true));\n        });\n    } else if (loc === \"..\") {\n        // all descendent parent properties\n        // Check remaining expression with val's immediate children\n        addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));\n        this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb)=>{\n            // We don't join m and x here because we only want parents,\n            //   not scalar values\n            if (typeof v[m] === \"object\") {\n                // Keep going with recursive descent on val's\n                //   object children\n                addRet(this._trace(unshift(l, _x), v[m], push(p, m), v, m, cb, true));\n            }\n        }); // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n    } else if (loc === \"^\") {\n        // This is not a final endpoint, so we do not invoke the callback here\n        this._hasParentSelector = true;\n        return {\n            path: path.slice(0, -1),\n            expr: x,\n            isParentSelector: true\n        };\n    } else if (loc === \"~\") {\n        // property name\n        retObj = {\n            path: push(path, loc),\n            value: parentPropName,\n            parent,\n            parentProperty: null\n        };\n        this._handleCallback(retObj, callback, \"property\");\n        return retObj;\n    } else if (loc === \"$\") {\n        // root only\n        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n    } else if (/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(loc)) {\n        // [start:end:step]  Python slice syntax\n        addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));\n    } else if (loc.indexOf(\"?(\") === 0) {\n        // [?(expr)] (filtering)\n        if (this.currPreventEval) {\n            throw new Error(\"Eval [?(expr)] prevented in JSONPath expression.\");\n        }\n        this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb)=>{\n            if (this._eval(l.replace(/^\\?\\((.*?)\\)$/u, \"$1\"), v[m], m, p, par, pr)) {\n                addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true));\n            }\n        });\n    } else if (loc[0] === \"(\") {\n        // [(expr)] (dynamic property/index)\n        if (this.currPreventEval) {\n            throw new Error(\"Eval [(expr)] prevented in JSONPath expression.\");\n        } // As this will resolve to a property name (but we don't know it\n        //  yet), property and parent information is relative to the\n        //  parent of the property to which this expression will resolve\n        addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));\n    } else if (loc[0] === \"@\") {\n        // value type: @boolean(), etc.\n        let addType = false;\n        const valueType = loc.slice(1, -2);\n        switch(valueType){\n            case \"scalar\":\n                if (!val || ![\n                    \"object\",\n                    \"function\"\n                ].includes(typeof val)) {\n                    addType = true;\n                }\n                break;\n            case \"boolean\":\n            case \"string\":\n            case \"undefined\":\n            case \"function\":\n                // eslint-disable-next-line valid-typeof\n                if (typeof val === valueType) {\n                    addType = true;\n                }\n                break;\n            case \"integer\":\n                if (Number.isFinite(val) && !(val % 1)) {\n                    addType = true;\n                }\n                break;\n            case \"number\":\n                if (Number.isFinite(val)) {\n                    addType = true;\n                }\n                break;\n            case \"nonFinite\":\n                if (typeof val === \"number\" && !Number.isFinite(val)) {\n                    addType = true;\n                }\n                break;\n            case \"object\":\n                // eslint-disable-next-line valid-typeof\n                if (val && typeof val === valueType) {\n                    addType = true;\n                }\n                break;\n            case \"array\":\n                if (Array.isArray(val)) {\n                    addType = true;\n                }\n                break;\n            case \"other\":\n                addType = this.currOtherTypeCallback(val, path, parent, parentPropName);\n                break;\n            case \"null\":\n                if (val === null) {\n                    addType = true;\n                }\n                break;\n            /* istanbul ignore next */ default:\n                throw new TypeError(\"Unknown value type \" + valueType);\n        }\n        if (addType) {\n            retObj = {\n                path,\n                value: val,\n                parent,\n                parentProperty: parentPropName\n            };\n            this._handleCallback(retObj, callback, \"value\");\n            return retObj;\n        } // `-escaped property\n    } else if (loc[0] === \"`\" && val && hasOwnProp.call(val, loc.slice(1))) {\n        const locProp = loc.slice(1);\n        addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));\n    } else if (loc.includes(\",\")) {\n        // [name1,name2,...]\n        const parts = loc.split(\",\");\n        for (const part of parts){\n            addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));\n        } // simple case--directly follow property\n    } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));\n    } // We check the resulting values for parent selections. For parent\n    // selections we discard the value object and continue the trace with the\n    // current val object\n    if (this._hasParentSelector) {\n        for(let t = 0; t < ret.length; t++){\n            const rett = ret[t];\n            if (rett && rett.isParentSelector) {\n                const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);\n                if (Array.isArray(tmp)) {\n                    ret[t] = tmp[0];\n                    const tl = tmp.length;\n                    for(let tt = 1; tt < tl; tt++){\n                        t++;\n                        ret.splice(t, 0, tmp[tt]);\n                    }\n                } else {\n                    ret[t] = tmp;\n                }\n            }\n        }\n    }\n    return ret;\n};\nJSONPath.prototype._walk = function(loc, expr, val, path, parent, parentPropName, callback, f) {\n    if (Array.isArray(val)) {\n        const n = val.length;\n        for(let i = 0; i < n; i++){\n            f(i, loc, expr, val, path, parent, parentPropName, callback);\n        }\n    } else if (val && typeof val === \"object\") {\n        Object.keys(val).forEach((m)=>{\n            f(m, loc, expr, val, path, parent, parentPropName, callback);\n        });\n    }\n};\nJSONPath.prototype._slice = function(loc, expr, val, path, parent, parentPropName, callback) {\n    if (!Array.isArray(val)) {\n        return undefined;\n    }\n    const len = val.length, parts = loc.split(\":\"), step = parts[2] && Number.parseInt(parts[2]) || 1;\n    let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;\n    start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);\n    end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);\n    const ret = [];\n    for(let i = start; i < end; i += step){\n        const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true); // Should only be possible to be an array here since first part of\n        //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n        //     nor begin with `@` (as could return objects)\n        // This was causing excessive stack size in Node (with or\n        //  without Babel) against our performance test: `ret.push(...tmp);`\n        tmp.forEach((t)=>{\n            ret.push(t);\n        });\n    }\n    return ret;\n};\nJSONPath.prototype._eval = function(code, _v, _vname, path, parent, parentPropName) {\n    if (code.includes(\"@parentProperty\")) {\n        this.currSandbox._$_parentProperty = parentPropName;\n        code = code.replace(/@parentProperty/gu, \"_$_parentProperty\");\n    }\n    if (code.includes(\"@parent\")) {\n        this.currSandbox._$_parent = parent;\n        code = code.replace(/@parent/gu, \"_$_parent\");\n    }\n    if (code.includes(\"@property\")) {\n        this.currSandbox._$_property = _vname;\n        code = code.replace(/@property/gu, \"_$_property\");\n    }\n    if (code.includes(\"@path\")) {\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([\n            _vname\n        ]));\n        code = code.replace(/@path/gu, \"_$_path\");\n    }\n    if (code.includes(\"@root\")) {\n        this.currSandbox._$_root = this.json;\n        code = code.replace(/@root/gu, \"_$_root\");\n    }\n    if (/@([.\\s)[])/u.test(code)) {\n        this.currSandbox._$_v = _v;\n        code = code.replace(/@([.\\s)[])/gu, \"_$_v$1\");\n    }\n    try {\n        return this.vm.runInNewContext(code, this.currSandbox);\n    } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(e);\n        throw new Error(\"jsonPath: \" + e.message + \": \" + code);\n    }\n}; // PUBLIC CLASS PROPERTIES AND METHODS\n// Could store the cache object itself\nJSONPath.cache = {};\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */ JSONPath.toPathString = function(pathArr) {\n    const x = pathArr, n = x.length;\n    let p = \"$\";\n    for(let i = 1; i < n; i++){\n        if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n            p += /^[0-9*]+$/u.test(x[i]) ? \"[\" + x[i] + \"]\" : \"['\" + x[i] + \"']\";\n        }\n    }\n    return p;\n};\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */ JSONPath.toPointer = function(pointer) {\n    const x = pointer, n = x.length;\n    let p = \"\";\n    for(let i = 1; i < n; i++){\n        if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n            p += \"/\" + x[i].toString().replace(/~/gu, \"~0\").replace(/\\//gu, \"~1\");\n        }\n    }\n    return p;\n};\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */ JSONPath.toPathArray = function(expr) {\n    const { cache } = JSONPath;\n    if (cache[expr]) {\n        return cache[expr].concat();\n    }\n    const subx = [];\n    const normalized = expr // Properties\n    .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu, \";$&;\") // Parenthetical evaluations (filtering and otherwise), directly\n    //   within brackets or single quotes\n    .replace(/[['](\\??\\(.*?\\))[\\]']/gu, function($0, $1) {\n        return \"[#\" + (subx.push($1) - 1) + \"]\";\n    }) // Escape periods and tildes within properties\n    .replace(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function($0, prop) {\n        return \"['\" + prop.replace(/\\./gu, \"%@%\").replace(/~/gu, \"%%@@%%\") + \"']\";\n    }) // Properties operator\n    .replace(/~/gu, \";~;\") // Split by property boundaries\n    .replace(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, \";\") // Reinsert periods within properties\n    .replace(/%@%/gu, \".\") // Reinsert tildes within properties\n    .replace(/%%@@%%/gu, \"~\") // Parent\n    .replace(/(?:;)?(\\^+)(?:;)?/gu, function($0, ups) {\n        return \";\" + ups.split(\"\").join(\";\") + \";\";\n    }) // Descendents\n    .replace(/;;;|;;/gu, \";..;\") // Remove trailing\n    .replace(/;$|'?\\]|'$/gu, \"\");\n    const exprList = normalized.split(\";\").map(function(exp) {\n        const match = exp.match(/#(\\d+)/u);\n        return !match || !match[1] ? exp : subx[match[1]];\n    });\n    cache[expr] = exprList;\n    return cache[expr].concat();\n};\nJSONPath.prototype.vm = vm__default[\"default\"];\nexports.JSONPath = JSONPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNvbnBhdGgtcGx1cy9kaXN0L2luZGV4LW5vZGUtY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLEtBQUtDLG1CQUFPQSxDQUFDO0FBRWpCLFNBQVNDLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsY0FBYyxXQUFXLEdBQUVGLHNCQUFzQkY7QUFFckQsTUFBTSxFQUNKSyxnQkFBZ0JDLFVBQVUsRUFDM0IsR0FBR1YsT0FBT1csU0FBUztBQUNwQjs7QUFFQSxHQUVBOzs7OztDQUtDLEdBRUQsU0FBU0MsS0FBS0MsR0FBRyxFQUFFQyxJQUFJO0lBQ3JCRCxNQUFNQSxJQUFJRSxLQUFLO0lBQ2ZGLElBQUlELElBQUksQ0FBQ0U7SUFDVCxPQUFPRDtBQUNUO0FBQ0E7Ozs7O0NBS0MsR0FHRCxTQUFTRyxRQUFRRixJQUFJLEVBQUVELEdBQUc7SUFDeEJBLE1BQU1BLElBQUlFLEtBQUs7SUFDZkYsSUFBSUcsT0FBTyxDQUFDRjtJQUNaLE9BQU9EO0FBQ1Q7QUFDQTs7O0NBR0MsR0FHRCxNQUFNSSxpQkFBaUJDO0lBQ3JCOztHQUVDLEdBQ0RDLFlBQVloQixLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDLGtFQUFrRTtRQUN4RSxJQUFJLENBQUNpQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDakIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2tCLElBQUksR0FBRztJQUNkO0FBRUY7QUFDQTs7Ozs7O0FBTUEsR0FFQTs7Ozs7O0FBTUEsR0FFQTs7Ozs7OztBQU9BLEdBRUEsa0hBQWtILEdBRWxIOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUVELGlIQUFpSCxHQUVqSDs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUdELFNBQVNDLFNBQVND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R0FBR29CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l4LWNtcy1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvanNvbnBhdGgtcGx1cy9kaXN0L2luZGV4LW5vZGUtY2pzLmpzPzI4YTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdm0gPSByZXF1aXJlKCd2bScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIHZtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeSh2bSk7XG5cbmNvbnN0IHtcbiAgaGFzT3duUHJvcGVydHk6IGhhc093blByb3Bcbn0gPSBPYmplY3QucHJvdG90eXBlO1xuLyoqXG4qIEB0eXBlZGVmIHtudWxsfGJvb2xlYW58bnVtYmVyfHN0cmluZ3xQbGFpbk9iamVjdHxHZW5lcmljQXJyYXl9IEpTT05PYmplY3RcbiovXG5cbi8qKlxuICogQ29waWVzIGFycmF5IGFuZCB0aGVuIHB1c2hlcyBpdGVtIGludG8gaXQuXG4gKiBAcGFyYW0ge0dlbmVyaWNBcnJheX0gYXJyIEFycmF5IHRvIGNvcHkgYW5kIGludG8gd2hpY2ggdG8gcHVzaFxuICogQHBhcmFtIHthbnl9IGl0ZW0gQXJyYXkgaXRlbSB0byBhZGQgKHRvIGVuZClcbiAqIEByZXR1cm5zIHtHZW5lcmljQXJyYXl9IENvcHkgb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gcHVzaChhcnIsIGl0ZW0pIHtcbiAgYXJyID0gYXJyLnNsaWNlKCk7XG4gIGFyci5wdXNoKGl0ZW0pO1xuICByZXR1cm4gYXJyO1xufVxuLyoqXG4gKiBDb3BpZXMgYXJyYXkgYW5kIHRoZW4gdW5zaGlmdHMgaXRlbSBpbnRvIGl0LlxuICogQHBhcmFtIHthbnl9IGl0ZW0gQXJyYXkgaXRlbSB0byBhZGQgKHRvIGJlZ2lubmluZylcbiAqIEBwYXJhbSB7R2VuZXJpY0FycmF5fSBhcnIgQXJyYXkgdG8gY29weSBhbmQgaW50byB3aGljaCB0byB1bnNoaWZ0XG4gKiBAcmV0dXJucyB7R2VuZXJpY0FycmF5fSBDb3B5IG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICovXG5cblxuZnVuY3Rpb24gdW5zaGlmdChpdGVtLCBhcnIpIHtcbiAgYXJyID0gYXJyLnNsaWNlKCk7XG4gIGFyci51bnNoaWZ0KGl0ZW0pO1xuICByZXR1cm4gYXJyO1xufVxuLyoqXG4gKiBDYXVnaHQgd2hlbiBKU09OUGF0aCBpcyB1c2VkIHdpdGhvdXQgYG5ld2AgYnV0IHJldGhyb3duIGlmIHdpdGggYG5ld2BcbiAqIEBleHRlbmRzIEVycm9yXG4gKi9cblxuXG5jbGFzcyBOZXdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgZXZhbHVhdGVkIHNjYWxhciB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcignSlNPTlBhdGggc2hvdWxkIG5vdCBiZSBjYWxsZWQgd2l0aCBcIm5ld1wiIChpdCBwcmV2ZW50cyByZXR1cm4gJyArICdvZiAodW53cmFwcGVkKSBzY2FsYXIgdmFsdWVzKScpO1xuICAgIHRoaXMuYXZvaWROZXcgPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5hbWUgPSAnTmV3RXJyb3InO1xuICB9XG5cbn1cbi8qKlxuKiBAdHlwZWRlZiB7UGxhaW5PYmplY3R9IFJldHVybk9iamVjdFxuKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aFxuKiBAcHJvcGVydHkge0pTT05PYmplY3R9IHZhbHVlXG4qIEBwcm9wZXJ0eSB7UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fSBwYXJlbnRcbiogQHByb3BlcnR5IHtzdHJpbmd9IHBhcmVudFByb3BlcnR5XG4qL1xuXG4vKipcbiogQGNhbGxiYWNrIEpTT05QYXRoQ2FsbGJhY2tcbiogQHBhcmFtIHtzdHJpbmd8UGxhaW5PYmplY3R9IHByZWZlcnJlZE91dHB1dFxuKiBAcGFyYW0ge1widmFsdWVcInxcInByb3BlcnR5XCJ9IHR5cGVcbiogQHBhcmFtIHtSZXR1cm5PYmplY3R9IGZ1bGxSZXRPYmpcbiogQHJldHVybnMge3ZvaWR9XG4qL1xuXG4vKipcbiogQGNhbGxiYWNrIE90aGVyVHlwZUNhbGxiYWNrXG4qIEBwYXJhbSB7SlNPTk9iamVjdH0gdmFsXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4qIEBwYXJhbSB7UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fSBwYXJlbnRcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFByb3BOYW1lXG4qIEByZXR1cm5zIHtib29sZWFufVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAtLSBDYW4gbWFrZSBtdWx0aWxpbmUgdHlwZSBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vc3lhdm9yc2t5L2NvbW1lbnQtcGFyc2VyL2lzc3Vlcy8xMDkgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UGxhaW5PYmplY3R9IEpTT05QYXRoT3B0aW9uc1xuICogQHByb3BlcnR5IHtKU09OfSBqc29uXG4gKiBAcHJvcGVydHkge3N0cmluZ3xzdHJpbmdbXX0gcGF0aFxuICogQHByb3BlcnR5IHtcInZhbHVlXCJ8XCJwYXRoXCJ8XCJwb2ludGVyXCJ8XCJwYXJlbnRcInxcInBhcmVudFByb3BlcnR5XCJ8XCJhbGxcIn0gW3Jlc3VsdFR5cGU9XCJ2YWx1ZVwiXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmxhdHRlbj1mYWxzZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXA9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7UGxhaW5PYmplY3R9IFtzYW5kYm94PXt9XVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHJldmVudEV2YWw9ZmFsc2VdXG4gKiBAcHJvcGVydHkge1BsYWluT2JqZWN0fEdlbmVyaWNBcnJheXxudWxsfSBbcGFyZW50PW51bGxdXG4gKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcGFyZW50UHJvcGVydHk9bnVsbF1cbiAqIEBwcm9wZXJ0eSB7SlNPTlBhdGhDYWxsYmFja30gW2NhbGxiYWNrXVxuICogQHByb3BlcnR5IHtPdGhlclR5cGVDYWxsYmFja30gW290aGVyVHlwZUNhbGxiYWNrXSBEZWZhdWx0cyB0b1xuICogICBmdW5jdGlvbiB3aGljaCB0aHJvd3Mgb24gZW5jb3VudGVyaW5nIGBAb3RoZXJgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvc3RhcnQ9dHJ1ZV1cbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gLS0gQ2FuIG1ha2UgbXVsdGlsaW5lIHR5cGUgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL3N5YXZvcnNreS9jb21tZW50LXBhcnNlci9pc3N1ZXMvMTA5ICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SlNPTlBhdGhPcHRpb25zfSBvcHRzIElmIGEgc3RyaW5nLCB3aWxsIGJlIHRyZWF0ZWQgYXMgYGV4cHJgXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4cHJdIEpTT04gcGF0aCB0byBldmFsdWF0ZVxuICogQHBhcmFtIHtKU09OfSBbb2JqXSBKU09OIG9iamVjdCB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gKiBAcGFyYW0ge0pTT05QYXRoQ2FsbGJhY2t9IFtjYWxsYmFja10gUGFzc2VkIDMgYXJndW1lbnRzOiAxKSBkZXNpcmVkIHBheWxvYWRcbiAqICAgICBwZXIgYHJlc3VsdFR5cGVgLCAyKSBgXCJ2YWx1ZVwifFwicHJvcGVydHlcImAsIDMpIEZ1bGwgcmV0dXJuZWQgb2JqZWN0IHdpdGhcbiAqICAgICBhbGwgcGF5bG9hZHNcbiAqIEBwYXJhbSB7T3RoZXJUeXBlQ2FsbGJhY2t9IFtvdGhlclR5cGVDYWxsYmFja10gSWYgYEBvdGhlcigpYCBpcyBhdCB0aGUgZW5kXG4gKiAgIG9mIG9uZSdzIHF1ZXJ5LCB0aGlzIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgaXRlbSwgaXRzXG4gKiAgIHBhdGgsIGl0cyBwYXJlbnQsIGFuZCBpdHMgcGFyZW50J3MgcHJvcGVydHkgbmFtZSwgYW5kIGl0IHNob3VsZCByZXR1cm5cbiAqICAgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VwcGxpZWQgdmFsdWUgYmVsb25ncyB0byB0aGUgXCJvdGhlclwiXG4gKiAgIHR5cGUgb3Igbm90IChvciBpdCBtYXkgaGFuZGxlIHRyYW5zZm9ybWF0aW9ucyBhbmQgcmV0dXJuIGBmYWxzZWApLlxuICogQHJldHVybnMge0pTT05QYXRofVxuICogQGNsYXNzXG4gKi9cblxuXG5mdW5jdGlvbiBKU09OUGF0aChvcHRzLCBleHByLCBvYmosIGNhbGxiYWNrLCBvdGhlclR5cGVDYWxsYmFjaykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEpTT05QYXRoKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEpTT05QYXRoKG9wdHMsIGV4cHIsIG9iaiwgY2FsbGJhY2ssIG90aGVyVHlwZUNhbGxiYWNrKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUuYXZvaWROZXcpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgIG90aGVyVHlwZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBvYmo7XG4gICAgb2JqID0gZXhwcjtcbiAgICBleHByID0gb3B0cztcbiAgICBvcHRzID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG9wdE9iaiA9IG9wdHMgJiYgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5qc29uID0gb3B0cy5qc29uIHx8IG9iajtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoIHx8IGV4cHI7XG4gIHRoaXMucmVzdWx0VHlwZSA9IG9wdHMucmVzdWx0VHlwZSB8fCAndmFsdWUnO1xuICB0aGlzLmZsYXR0ZW4gPSBvcHRzLmZsYXR0ZW4gfHwgZmFsc2U7XG4gIHRoaXMud3JhcCA9IGhhc093blByb3AuY2FsbChvcHRzLCAnd3JhcCcpID8gb3B0cy53cmFwIDogdHJ1ZTtcbiAgdGhpcy5zYW5kYm94ID0gb3B0cy5zYW5kYm94IHx8IHt9O1xuICB0aGlzLnByZXZlbnRFdmFsID0gb3B0cy5wcmV2ZW50RXZhbCB8fCBmYWxzZTtcbiAgdGhpcy5wYXJlbnQgPSBvcHRzLnBhcmVudCB8fCBudWxsO1xuICB0aGlzLnBhcmVudFByb3BlcnR5ID0gb3B0cy5wYXJlbnRQcm9wZXJ0eSB8fCBudWxsO1xuICB0aGlzLmNhbGxiYWNrID0gb3B0cy5jYWxsYmFjayB8fCBjYWxsYmFjayB8fCBudWxsO1xuXG4gIHRoaXMub3RoZXJUeXBlQ2FsbGJhY2sgPSBvcHRzLm90aGVyVHlwZUNhbGxiYWNrIHx8IG90aGVyVHlwZUNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYW4gb3RoZXJUeXBlQ2FsbGJhY2sgY2FsbGJhY2sgb3B0aW9uICcgKyAnd2l0aCB0aGUgQG90aGVyKCkgb3BlcmF0b3IuJyk7XG4gIH07XG5cbiAgaWYgKG9wdHMuYXV0b3N0YXJ0ICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBwYXRoOiBvcHRPYmogPyBvcHRzLnBhdGggOiBleHByXG4gICAgfTtcblxuICAgIGlmICghb3B0T2JqKSB7XG4gICAgICBhcmdzLmpzb24gPSBvYmo7XG4gICAgfSBlbHNlIGlmICgnanNvbicgaW4gb3B0cykge1xuICAgICAgYXJncy5qc29uID0gb3B0cy5qc29uO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IHRoaXMuZXZhbHVhdGUoYXJncyk7XG5cbiAgICBpZiAoIXJldCB8fCB0eXBlb2YgcmV0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE5ld0Vycm9yKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufSAvLyBQVUJMSUMgTUVUSE9EU1xuXG5cbkpTT05QYXRoLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChleHByLCBqc29uLCBjYWxsYmFjaywgb3RoZXJUeXBlQ2FsbGJhY2spIHtcbiAgbGV0IGN1cnJQYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgIGN1cnJQYXJlbnRQcm9wZXJ0eSA9IHRoaXMucGFyZW50UHJvcGVydHk7XG4gIGxldCB7XG4gICAgZmxhdHRlbixcbiAgICB3cmFwXG4gIH0gPSB0aGlzO1xuICB0aGlzLmN1cnJSZXN1bHRUeXBlID0gdGhpcy5yZXN1bHRUeXBlO1xuICB0aGlzLmN1cnJQcmV2ZW50RXZhbCA9IHRoaXMucHJldmVudEV2YWw7XG4gIHRoaXMuY3VyclNhbmRib3ggPSB0aGlzLnNhbmRib3g7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgdGhpcy5jYWxsYmFjaztcbiAgdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2sgPSBvdGhlclR5cGVDYWxsYmFjayB8fCB0aGlzLm90aGVyVHlwZUNhbGxiYWNrO1xuICBqc29uID0ganNvbiB8fCB0aGlzLmpzb247XG4gIGV4cHIgPSBleHByIHx8IHRoaXMucGF0aDtcblxuICBpZiAoZXhwciAmJiB0eXBlb2YgZXhwciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZXhwcikpIHtcbiAgICBpZiAoIWV4cHIucGF0aCAmJiBleHByLnBhdGggIT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBcInBhdGhcIiBwcm9wZXJ0eSB3aGVuIHByb3ZpZGluZyBhbiBvYmplY3QgJyArICdhcmd1bWVudCB0byBKU09OUGF0aC5ldmFsdWF0ZSgpLicpO1xuICAgIH1cblxuICAgIGlmICghaGFzT3duUHJvcC5jYWxsKGV4cHIsICdqc29uJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIFwianNvblwiIHByb3BlcnR5IHdoZW4gcHJvdmlkaW5nIGFuIG9iamVjdCAnICsgJ2FyZ3VtZW50IHRvIEpTT05QYXRoLmV2YWx1YXRlKCkuJyk7XG4gICAgfVxuXG4gICAgKHtcbiAgICAgIGpzb25cbiAgICB9ID0gZXhwcik7XG4gICAgZmxhdHRlbiA9IGhhc093blByb3AuY2FsbChleHByLCAnZmxhdHRlbicpID8gZXhwci5mbGF0dGVuIDogZmxhdHRlbjtcbiAgICB0aGlzLmN1cnJSZXN1bHRUeXBlID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdyZXN1bHRUeXBlJykgPyBleHByLnJlc3VsdFR5cGUgOiB0aGlzLmN1cnJSZXN1bHRUeXBlO1xuICAgIHRoaXMuY3VyclNhbmRib3ggPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3NhbmRib3gnKSA/IGV4cHIuc2FuZGJveCA6IHRoaXMuY3VyclNhbmRib3g7XG4gICAgd3JhcCA9IGhhc093blByb3AuY2FsbChleHByLCAnd3JhcCcpID8gZXhwci53cmFwIDogd3JhcDtcbiAgICB0aGlzLmN1cnJQcmV2ZW50RXZhbCA9IGhhc093blByb3AuY2FsbChleHByLCAncHJldmVudEV2YWwnKSA/IGV4cHIucHJldmVudEV2YWwgOiB0aGlzLmN1cnJQcmV2ZW50RXZhbDtcbiAgICBjYWxsYmFjayA9IGhhc093blByb3AuY2FsbChleHByLCAnY2FsbGJhY2snKSA/IGV4cHIuY2FsbGJhY2sgOiBjYWxsYmFjaztcbiAgICB0aGlzLmN1cnJPdGhlclR5cGVDYWxsYmFjayA9IGhhc093blByb3AuY2FsbChleHByLCAnb3RoZXJUeXBlQ2FsbGJhY2snKSA/IGV4cHIub3RoZXJUeXBlQ2FsbGJhY2sgOiB0aGlzLmN1cnJPdGhlclR5cGVDYWxsYmFjaztcbiAgICBjdXJyUGFyZW50ID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdwYXJlbnQnKSA/IGV4cHIucGFyZW50IDogY3VyclBhcmVudDtcbiAgICBjdXJyUGFyZW50UHJvcGVydHkgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3BhcmVudFByb3BlcnR5JykgPyBleHByLnBhcmVudFByb3BlcnR5IDogY3VyclBhcmVudFByb3BlcnR5O1xuICAgIGV4cHIgPSBleHByLnBhdGg7XG4gIH1cblxuICBjdXJyUGFyZW50ID0gY3VyclBhcmVudCB8fCBudWxsO1xuICBjdXJyUGFyZW50UHJvcGVydHkgPSBjdXJyUGFyZW50UHJvcGVydHkgfHwgbnVsbDtcblxuICBpZiAoQXJyYXkuaXNBcnJheShleHByKSkge1xuICAgIGV4cHIgPSBKU09OUGF0aC50b1BhdGhTdHJpbmcoZXhwcik7XG4gIH1cblxuICBpZiAoIWV4cHIgJiYgZXhwciAhPT0gJycgfHwgIWpzb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZXhwckxpc3QgPSBKU09OUGF0aC50b1BhdGhBcnJheShleHByKTtcblxuICBpZiAoZXhwckxpc3RbMF0gPT09ICckJyAmJiBleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgZXhwckxpc3Quc2hpZnQoKTtcbiAgfVxuXG4gIHRoaXMuX2hhc1BhcmVudFNlbGVjdG9yID0gbnVsbDtcblxuICBjb25zdCByZXN1bHQgPSB0aGlzLl90cmFjZShleHByTGlzdCwganNvbiwgWyckJ10sIGN1cnJQYXJlbnQsIGN1cnJQYXJlbnRQcm9wZXJ0eSwgY2FsbGJhY2spLmZpbHRlcihmdW5jdGlvbiAoZWEpIHtcbiAgICByZXR1cm4gZWEgJiYgIWVhLmlzUGFyZW50U2VsZWN0b3I7XG4gIH0pO1xuXG4gIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgIHJldHVybiB3cmFwID8gW10gOiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIXdyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiAhcmVzdWx0WzBdLmhhc0FyckV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJlZmVycmVkT3V0cHV0KHJlc3VsdFswXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnJlZHVjZSgocnNsdCwgZWEpID0+IHtcbiAgICBjb25zdCB2YWxPclBhdGggPSB0aGlzLl9nZXRQcmVmZXJyZWRPdXRwdXQoZWEpO1xuXG4gICAgaWYgKGZsYXR0ZW4gJiYgQXJyYXkuaXNBcnJheSh2YWxPclBhdGgpKSB7XG4gICAgICByc2x0ID0gcnNsdC5jb25jYXQodmFsT3JQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnNsdC5wdXNoKHZhbE9yUGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzbHQ7XG4gIH0sIFtdKTtcbn07IC8vIFBSSVZBVEUgTUVUSE9EU1xuXG5cbkpTT05QYXRoLnByb3RvdHlwZS5fZ2V0UHJlZmVycmVkT3V0cHV0ID0gZnVuY3Rpb24gKGVhKSB7XG4gIGNvbnN0IHJlc3VsdFR5cGUgPSB0aGlzLmN1cnJSZXN1bHRUeXBlO1xuXG4gIHN3aXRjaCAocmVzdWx0VHlwZSkge1xuICAgIGNhc2UgJ2FsbCc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBBcnJheS5pc0FycmF5KGVhLnBhdGgpID8gZWEucGF0aCA6IEpTT05QYXRoLnRvUGF0aEFycmF5KGVhLnBhdGgpO1xuICAgICAgICBlYS5wb2ludGVyID0gSlNPTlBhdGgudG9Qb2ludGVyKHBhdGgpO1xuICAgICAgICBlYS5wYXRoID0gdHlwZW9mIGVhLnBhdGggPT09ICdzdHJpbmcnID8gZWEucGF0aCA6IEpTT05QYXRoLnRvUGF0aFN0cmluZyhlYS5wYXRoKTtcbiAgICAgICAgcmV0dXJuIGVhO1xuICAgICAgfVxuXG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ3BhcmVudCc6XG4gICAgY2FzZSAncGFyZW50UHJvcGVydHknOlxuICAgICAgcmV0dXJuIGVhW3Jlc3VsdFR5cGVdO1xuXG4gICAgY2FzZSAncGF0aCc6XG4gICAgICByZXR1cm4gSlNPTlBhdGgudG9QYXRoU3RyaW5nKGVhW3Jlc3VsdFR5cGVdKTtcblxuICAgIGNhc2UgJ3BvaW50ZXInOlxuICAgICAgcmV0dXJuIEpTT05QYXRoLnRvUG9pbnRlcihlYS5wYXRoKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIHJlc3VsdCB0eXBlJyk7XG4gIH1cbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS5faGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZnVsbFJldE9iaiwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJlZmVycmVkT3V0cHV0ID0gdGhpcy5fZ2V0UHJlZmVycmVkT3V0cHV0KGZ1bGxSZXRPYmopO1xuXG4gICAgZnVsbFJldE9iai5wYXRoID0gdHlwZW9mIGZ1bGxSZXRPYmoucGF0aCA9PT0gJ3N0cmluZycgPyBmdWxsUmV0T2JqLnBhdGggOiBKU09OUGF0aC50b1BhdGhTdHJpbmcoZnVsbFJldE9iai5wYXRoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG5cbiAgICBjYWxsYmFjayhwcmVmZXJyZWRPdXRwdXQsIHR5cGUsIGZ1bGxSZXRPYmopO1xuICB9XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJcbiAqIEBwYXJhbSB7SlNPTk9iamVjdH0gdmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtQbGFpbk9iamVjdHxHZW5lcmljQXJyYXl9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFByb3BOYW1lXG4gKiBAcGFyYW0ge0pTT05QYXRoQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0FyckV4cHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0ZXJhbFByaW9yaXR5XG4gKiBAcmV0dXJucyB7UmV0dXJuT2JqZWN0fFJldHVybk9iamVjdFtdfVxuICovXG5cblxuSlNPTlBhdGgucHJvdG90eXBlLl90cmFjZSA9IGZ1bmN0aW9uIChleHByLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByLCBsaXRlcmFsUHJpb3JpdHkpIHtcbiAgLy8gTm8gZXhwciB0byBmb2xsb3c/IHJldHVybiBwYXRoIGFuZCB2YWx1ZSBhcyB0aGUgcmVzdWx0IG9mXG4gIC8vICB0aGlzIHRyYWNlIGJyYW5jaFxuICBsZXQgcmV0T2JqO1xuXG4gIGlmICghZXhwci5sZW5ndGgpIHtcbiAgICByZXRPYmogPSB7XG4gICAgICBwYXRoLFxuICAgICAgdmFsdWU6IHZhbCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudFByb3BlcnR5OiBwYXJlbnRQcm9wTmFtZSxcbiAgICAgIGhhc0FyckV4cHJcbiAgICB9O1xuXG4gICAgdGhpcy5faGFuZGxlQ2FsbGJhY2socmV0T2JqLCBjYWxsYmFjaywgJ3ZhbHVlJyk7XG5cbiAgICByZXR1cm4gcmV0T2JqO1xuICB9XG5cbiAgY29uc3QgbG9jID0gZXhwclswXSxcbiAgICAgICAgeCA9IGV4cHIuc2xpY2UoMSk7IC8vIFdlIG5lZWQgdG8gZ2F0aGVyIHRoZSByZXR1cm4gdmFsdWUgb2YgcmVjdXJzaXZlIHRyYWNlIGNhbGxzIGluIG9yZGVyIHRvXG4gIC8vIGRvIHRoZSBwYXJlbnQgc2VsIGNvbXB1dGF0aW9uLlxuXG4gIGNvbnN0IHJldCA9IFtdO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtSZXR1cm5PYmplY3R8UmV0dXJuT2JqZWN0W119IGVsZW1zXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICBmdW5jdGlvbiBhZGRSZXQoZWxlbXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtcykpIHtcbiAgICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgZXhjZXNzaXZlIHN0YWNrIHNpemUgaW4gTm9kZSAod2l0aCBvclxuICAgICAgLy8gIHdpdGhvdXQgQmFiZWwpIGFnYWluc3Qgb3VyIHBlcmZvcm1hbmNlIHRlc3Q6XG4gICAgICAvLyAgYHJldC5wdXNoKC4uLmVsZW1zKTtgXG4gICAgICBlbGVtcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICByZXQucHVzaCh0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChlbGVtcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCh0eXBlb2YgbG9jICE9PSAnc3RyaW5nJyB8fCBsaXRlcmFsUHJpb3JpdHkpICYmIHZhbCAmJiBoYXNPd25Qcm9wLmNhbGwodmFsLCBsb2MpKSB7XG4gICAgLy8gc2ltcGxlIGNhc2UtLWRpcmVjdGx5IGZvbGxvdyBwcm9wZXJ0eVxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWxbbG9jXSwgcHVzaChwYXRoLCBsb2MpLCB2YWwsIGxvYywgY2FsbGJhY2ssIGhhc0FyckV4cHIpKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLXN3aXRjaCAtLSBQYXJ0IG9mIGxhcmdlciBgaWZgXG4gIH0gZWxzZSBpZiAobG9jID09PSAnKicpIHtcbiAgICAvLyBhbGwgY2hpbGQgcHJvcGVydGllc1xuICAgIHRoaXMuX3dhbGsobG9jLCB4LCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCAobSwgbCwgX3gsIHYsIHAsIHBhciwgcHIsIGNiKSA9PiB7XG4gICAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdChtLCBfeCksIHYsIHAsIHBhciwgcHIsIGNiLCB0cnVlLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobG9jID09PSAnLi4nKSB7XG4gICAgLy8gYWxsIGRlc2NlbmRlbnQgcGFyZW50IHByb3BlcnRpZXNcbiAgICAvLyBDaGVjayByZW1haW5pbmcgZXhwcmVzc2lvbiB3aXRoIHZhbCdzIGltbWVkaWF0ZSBjaGlsZHJlblxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7XG5cbiAgICB0aGlzLl93YWxrKGxvYywgeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgKG0sIGwsIF94LCB2LCBwLCBwYXIsIHByLCBjYikgPT4ge1xuICAgICAgLy8gV2UgZG9uJ3Qgam9pbiBtIGFuZCB4IGhlcmUgYmVjYXVzZSB3ZSBvbmx5IHdhbnQgcGFyZW50cyxcbiAgICAgIC8vICAgbm90IHNjYWxhciB2YWx1ZXNcbiAgICAgIGlmICh0eXBlb2YgdlttXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gS2VlcCBnb2luZyB3aXRoIHJlY3Vyc2l2ZSBkZXNjZW50IG9uIHZhbCdzXG4gICAgICAgIC8vICAgb2JqZWN0IGNoaWxkcmVuXG4gICAgICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KGwsIF94KSwgdlttXSwgcHVzaChwLCBtKSwgdiwgbSwgY2IsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gVGhlIHBhcmVudCBzZWwgY29tcHV0YXRpb24gaXMgaGFuZGxlZCBpbiB0aGUgZnJhbWUgYWJvdmUgdXNpbmcgdGhlXG4gICAgLy8gYW5jZXN0b3Igb2JqZWN0IG9mIHZhbFxuXG4gIH0gZWxzZSBpZiAobG9jID09PSAnXicpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIGZpbmFsIGVuZHBvaW50LCBzbyB3ZSBkbyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBoZXJlXG4gICAgdGhpcy5faGFzUGFyZW50U2VsZWN0b3IgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLnNsaWNlKDAsIC0xKSxcbiAgICAgIGV4cHI6IHgsXG4gICAgICBpc1BhcmVudFNlbGVjdG9yOiB0cnVlXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsb2MgPT09ICd+Jykge1xuICAgIC8vIHByb3BlcnR5IG5hbWVcbiAgICByZXRPYmogPSB7XG4gICAgICBwYXRoOiBwdXNoKHBhdGgsIGxvYyksXG4gICAgICB2YWx1ZTogcGFyZW50UHJvcE5hbWUsXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRQcm9wZXJ0eTogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLl9oYW5kbGVDYWxsYmFjayhyZXRPYmosIGNhbGxiYWNrLCAncHJvcGVydHknKTtcblxuICAgIHJldHVybiByZXRPYmo7XG4gIH0gZWxzZSBpZiAobG9jID09PSAnJCcpIHtcbiAgICAvLyByb290IG9ubHlcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsLCBwYXRoLCBudWxsLCBudWxsLCBjYWxsYmFjaywgaGFzQXJyRXhwcikpO1xuICB9IGVsc2UgaWYgKC9eKC0/XFxkKik6KC0/XFxkKik6PyhcXGQqKSQvdS50ZXN0KGxvYykpIHtcbiAgICAvLyBbc3RhcnQ6ZW5kOnN0ZXBdICBQeXRob24gc2xpY2Ugc3ludGF4XG4gICAgYWRkUmV0KHRoaXMuX3NsaWNlKGxvYywgeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaykpO1xuICB9IGVsc2UgaWYgKGxvYy5pbmRleE9mKCc/KCcpID09PSAwKSB7XG4gICAgLy8gWz8oZXhwcildIChmaWx0ZXJpbmcpXG4gICAgaWYgKHRoaXMuY3VyclByZXZlbnRFdmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2YWwgWz8oZXhwcildIHByZXZlbnRlZCBpbiBKU09OUGF0aCBleHByZXNzaW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3dhbGsobG9jLCB4LCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCAobSwgbCwgX3gsIHYsIHAsIHBhciwgcHIsIGNiKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZXZhbChsLnJlcGxhY2UoL15cXD9cXCgoLio/KVxcKSQvdSwgJyQxJyksIHZbbV0sIG0sIHAsIHBhciwgcHIpKSB7XG4gICAgICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KG0sIF94KSwgdiwgcCwgcGFyLCBwciwgY2IsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsb2NbMF0gPT09ICcoJykge1xuICAgIC8vIFsoZXhwcildIChkeW5hbWljIHByb3BlcnR5L2luZGV4KVxuICAgIGlmICh0aGlzLmN1cnJQcmV2ZW50RXZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmFsIFsoZXhwcildIHByZXZlbnRlZCBpbiBKU09OUGF0aCBleHByZXNzaW9uLicpO1xuICAgIH0gLy8gQXMgdGhpcyB3aWxsIHJlc29sdmUgdG8gYSBwcm9wZXJ0eSBuYW1lIChidXQgd2UgZG9uJ3Qga25vdyBpdFxuICAgIC8vICB5ZXQpLCBwcm9wZXJ0eSBhbmQgcGFyZW50IGluZm9ybWF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vICBwYXJlbnQgb2YgdGhlIHByb3BlcnR5IHRvIHdoaWNoIHRoaXMgZXhwcmVzc2lvbiB3aWxsIHJlc29sdmVcblxuXG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQodGhpcy5fZXZhbChsb2MsIHZhbCwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoLnNsaWNlKDAsIC0xKSwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSksIHgpLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7XG4gIH0gZWxzZSBpZiAobG9jWzBdID09PSAnQCcpIHtcbiAgICAvLyB2YWx1ZSB0eXBlOiBAYm9vbGVhbigpLCBldGMuXG4gICAgbGV0IGFkZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSBsb2Muc2xpY2UoMSwgLTIpO1xuXG4gICAgc3dpdGNoICh2YWx1ZVR5cGUpIHtcbiAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGlmICghdmFsIHx8ICFbJ29iamVjdCcsICdmdW5jdGlvbiddLmluY2x1ZGVzKHR5cGVvZiB2YWwpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gdmFsdWVUeXBlKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsKSAmJiAhKHZhbCAlIDEpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbm9uRmluaXRlJzpcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNGaW5pdGUodmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSB2YWx1ZVR5cGUpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvdGhlcic6XG4gICAgICAgIGFkZFR5cGUgPSB0aGlzLmN1cnJPdGhlclR5cGVDYWxsYmFjayh2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIHZhbHVlIHR5cGUgJyArIHZhbHVlVHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKGFkZFR5cGUpIHtcbiAgICAgIHJldE9iaiA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRQcm9wZXJ0eTogcGFyZW50UHJvcE5hbWVcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2hhbmRsZUNhbGxiYWNrKHJldE9iaiwgY2FsbGJhY2ssICd2YWx1ZScpO1xuXG4gICAgICByZXR1cm4gcmV0T2JqO1xuICAgIH0gLy8gYC1lc2NhcGVkIHByb3BlcnR5XG5cbiAgfSBlbHNlIGlmIChsb2NbMF0gPT09ICdgJyAmJiB2YWwgJiYgaGFzT3duUHJvcC5jYWxsKHZhbCwgbG9jLnNsaWNlKDEpKSkge1xuICAgIGNvbnN0IGxvY1Byb3AgPSBsb2Muc2xpY2UoMSk7XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbFtsb2NQcm9wXSwgcHVzaChwYXRoLCBsb2NQcm9wKSwgdmFsLCBsb2NQcm9wLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgdHJ1ZSkpO1xuICB9IGVsc2UgaWYgKGxvYy5pbmNsdWRlcygnLCcpKSB7XG4gICAgLy8gW25hbWUxLG5hbWUyLC4uLl1cbiAgICBjb25zdCBwYXJ0cyA9IGxvYy5zcGxpdCgnLCcpO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdChwYXJ0LCB4KSwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgdHJ1ZSkpO1xuICAgIH0gLy8gc2ltcGxlIGNhc2UtLWRpcmVjdGx5IGZvbGxvdyBwcm9wZXJ0eVxuXG4gIH0gZWxzZSBpZiAoIWxpdGVyYWxQcmlvcml0eSAmJiB2YWwgJiYgaGFzT3duUHJvcC5jYWxsKHZhbCwgbG9jKSkge1xuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWxbbG9jXSwgcHVzaChwYXRoLCBsb2MpLCB2YWwsIGxvYywgY2FsbGJhY2ssIGhhc0FyckV4cHIsIHRydWUpKTtcbiAgfSAvLyBXZSBjaGVjayB0aGUgcmVzdWx0aW5nIHZhbHVlcyBmb3IgcGFyZW50IHNlbGVjdGlvbnMuIEZvciBwYXJlbnRcbiAgLy8gc2VsZWN0aW9ucyB3ZSBkaXNjYXJkIHRoZSB2YWx1ZSBvYmplY3QgYW5kIGNvbnRpbnVlIHRoZSB0cmFjZSB3aXRoIHRoZVxuICAvLyBjdXJyZW50IHZhbCBvYmplY3RcblxuXG4gIGlmICh0aGlzLl9oYXNQYXJlbnRTZWxlY3Rvcikge1xuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgcmV0Lmxlbmd0aDsgdCsrKSB7XG4gICAgICBjb25zdCByZXR0ID0gcmV0W3RdO1xuXG4gICAgICBpZiAocmV0dCAmJiByZXR0LmlzUGFyZW50U2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgdG1wID0gdGhpcy5fdHJhY2UocmV0dC5leHByLCB2YWwsIHJldHQucGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGhhc0FyckV4cHIpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRtcCkpIHtcbiAgICAgICAgICByZXRbdF0gPSB0bXBbMF07XG4gICAgICAgICAgY29uc3QgdGwgPSB0bXAubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChsZXQgdHQgPSAxOyB0dCA8IHRsOyB0dCsrKSB7XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICByZXQuc3BsaWNlKHQsIDAsIHRtcFt0dF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRbdF0gPSB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuSlNPTlBhdGgucHJvdG90eXBlLl93YWxrID0gZnVuY3Rpb24gKGxvYywgZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgZikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgbiA9IHZhbC5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgZihpLCBsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyh2YWwpLmZvckVhY2gobSA9PiB7XG4gICAgICBmKG0sIGxvYywgZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS5fc2xpY2UgPSBmdW5jdGlvbiAobG9jLCBleHByLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHZhbC5sZW5ndGgsXG4gICAgICAgIHBhcnRzID0gbG9jLnNwbGl0KCc6JyksXG4gICAgICAgIHN0ZXAgPSBwYXJ0c1syXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMl0pIHx8IDE7XG4gIGxldCBzdGFydCA9IHBhcnRzWzBdICYmIE51bWJlci5wYXJzZUludChwYXJ0c1swXSkgfHwgMCxcbiAgICAgIGVuZCA9IHBhcnRzWzFdICYmIE51bWJlci5wYXJzZUludChwYXJ0c1sxXSkgfHwgbGVuO1xuICBzdGFydCA9IHN0YXJ0IDwgMCA/IE1hdGgubWF4KDAsIHN0YXJ0ICsgbGVuKSA6IE1hdGgubWluKGxlbiwgc3RhcnQpO1xuICBlbmQgPSBlbmQgPCAwID8gTWF0aC5tYXgoMCwgZW5kICsgbGVuKSA6IE1hdGgubWluKGxlbiwgZW5kKTtcbiAgY29uc3QgcmV0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IHN0ZXApIHtcbiAgICBjb25zdCB0bXAgPSB0aGlzLl90cmFjZSh1bnNoaWZ0KGksIGV4cHIpLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCB0cnVlKTsgLy8gU2hvdWxkIG9ubHkgYmUgcG9zc2libGUgdG8gYmUgYW4gYXJyYXkgaGVyZSBzaW5jZSBmaXJzdCBwYXJ0IG9mXG4gICAgLy8gICBgYHVuc2hpZnQoaSwgZXhwcilgIHBhc3NlZCBpbiBhYm92ZSB3b3VsZCBub3QgYmUgZW1wdHksIG5vciBgfmAsXG4gICAgLy8gICAgIG5vciBiZWdpbiB3aXRoIGBAYCAoYXMgY291bGQgcmV0dXJuIG9iamVjdHMpXG4gICAgLy8gVGhpcyB3YXMgY2F1c2luZyBleGNlc3NpdmUgc3RhY2sgc2l6ZSBpbiBOb2RlICh3aXRoIG9yXG4gICAgLy8gIHdpdGhvdXQgQmFiZWwpIGFnYWluc3Qgb3VyIHBlcmZvcm1hbmNlIHRlc3Q6IGByZXQucHVzaCguLi50bXApO2BcblxuXG4gICAgdG1wLmZvckVhY2godCA9PiB7XG4gICAgICByZXQucHVzaCh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX2V2YWwgPSBmdW5jdGlvbiAoY29kZSwgX3YsIF92bmFtZSwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSkge1xuICBpZiAoY29kZS5pbmNsdWRlcygnQHBhcmVudFByb3BlcnR5JykpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3BhcmVudFByb3BlcnR5ID0gcGFyZW50UHJvcE5hbWU7XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQHBhcmVudFByb3BlcnR5L2d1LCAnXyRfcGFyZW50UHJvcGVydHknKTtcbiAgfVxuXG4gIGlmIChjb2RlLmluY2x1ZGVzKCdAcGFyZW50JykpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3BhcmVudCA9IHBhcmVudDtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AcGFyZW50L2d1LCAnXyRfcGFyZW50Jyk7XG4gIH1cblxuICBpZiAoY29kZS5pbmNsdWRlcygnQHByb3BlcnR5JykpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3Byb3BlcnR5ID0gX3ZuYW1lO1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0Bwcm9wZXJ0eS9ndSwgJ18kX3Byb3BlcnR5Jyk7XG4gIH1cblxuICBpZiAoY29kZS5pbmNsdWRlcygnQHBhdGgnKSkge1xuICAgIHRoaXMuY3VyclNhbmRib3guXyRfcGF0aCA9IEpTT05QYXRoLnRvUGF0aFN0cmluZyhwYXRoLmNvbmNhdChbX3ZuYW1lXSkpO1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0BwYXRoL2d1LCAnXyRfcGF0aCcpO1xuICB9XG5cbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0Byb290JykpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3Jvb3QgPSB0aGlzLmpzb247XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQHJvb3QvZ3UsICdfJF9yb290Jyk7XG4gIH1cblxuICBpZiAoL0AoWy5cXHMpW10pL3UudGVzdChjb2RlKSkge1xuICAgIHRoaXMuY3VyclNhbmRib3guXyRfdiA9IF92O1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0AoWy5cXHMpW10pL2d1LCAnXyRfdiQxJyk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0aGlzLnZtLnJ1bkluTmV3Q29udGV4dChjb2RlLCB0aGlzLmN1cnJTYW5kYm94KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdqc29uUGF0aDogJyArIGUubWVzc2FnZSArICc6ICcgKyBjb2RlKTtcbiAgfVxufTsgLy8gUFVCTElDIENMQVNTIFBST1BFUlRJRVMgQU5EIE1FVEhPRFNcbi8vIENvdWxkIHN0b3JlIHRoZSBjYWNoZSBvYmplY3QgaXRzZWxmXG5cblxuSlNPTlBhdGguY2FjaGUgPSB7fTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aEFyciBBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCBzdHJpbmdcbiAqL1xuXG5KU09OUGF0aC50b1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aEFycikge1xuICBjb25zdCB4ID0gcGF0aEFycixcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuICBsZXQgcCA9ICckJztcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgIGlmICghL14ofnxcXF58QC4qP1xcKFxcKSkkL3UudGVzdCh4W2ldKSkge1xuICAgICAgcCArPSAvXlswLTkqXSskL3UudGVzdCh4W2ldKSA/ICdbJyArIHhbaV0gKyAnXScgOiBcIlsnXCIgKyB4W2ldICsgXCInXVwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXIgSlNPTiBQYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBKU09OIFBvaW50ZXJcbiAqL1xuXG5cbkpTT05QYXRoLnRvUG9pbnRlciA9IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gIGNvbnN0IHggPSBwb2ludGVyLFxuICAgICAgICBuID0geC5sZW5ndGg7XG4gIGxldCBwID0gJyc7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoIS9eKH58XFxefEAuKj9cXChcXCkpJC91LnRlc3QoeFtpXSkpIHtcbiAgICAgIHAgKz0gJy8nICsgeFtpXS50b1N0cmluZygpLnJlcGxhY2UoL34vZ3UsICd+MCcpLnJlcGxhY2UoL1xcLy9ndSwgJ34xJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHA7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwciBFeHByZXNzaW9uIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuXG5cbkpTT05QYXRoLnRvUGF0aEFycmF5ID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgY29uc3Qge1xuICAgIGNhY2hlXG4gIH0gPSBKU09OUGF0aDtcblxuICBpZiAoY2FjaGVbZXhwcl0pIHtcbiAgICByZXR1cm4gY2FjaGVbZXhwcl0uY29uY2F0KCk7XG4gIH1cblxuICBjb25zdCBzdWJ4ID0gW107XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBleHByIC8vIFByb3BlcnRpZXNcbiAgLnJlcGxhY2UoL0AoPzpudWxsfGJvb2xlYW58bnVtYmVyfHN0cmluZ3xpbnRlZ2VyfHVuZGVmaW5lZHxub25GaW5pdGV8c2NhbGFyfGFycmF5fG9iamVjdHxmdW5jdGlvbnxvdGhlcilcXChcXCkvZ3UsICc7JCY7JykgLy8gUGFyZW50aGV0aWNhbCBldmFsdWF0aW9ucyAoZmlsdGVyaW5nIGFuZCBvdGhlcndpc2UpLCBkaXJlY3RseVxuICAvLyAgIHdpdGhpbiBicmFja2V0cyBvciBzaW5nbGUgcXVvdGVzXG4gIC5yZXBsYWNlKC9bWyddKFxcPz9cXCguKj9cXCkpW1xcXSddL2d1LCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgcmV0dXJuICdbIycgKyAoc3VieC5wdXNoKCQxKSAtIDEpICsgJ10nO1xuICB9KSAvLyBFc2NhcGUgcGVyaW9kcyBhbmQgdGlsZGVzIHdpdGhpbiBwcm9wZXJ0aWVzXG4gIC5yZXBsYWNlKC9cXFtbJ1wiXShbXidcXF1dKilbJ1wiXVxcXS9ndSwgZnVuY3Rpb24gKCQwLCBwcm9wKSB7XG4gICAgcmV0dXJuIFwiWydcIiArIHByb3AucmVwbGFjZSgvXFwuL2d1LCAnJUAlJykucmVwbGFjZSgvfi9ndSwgJyUlQEAlJScpICsgXCInXVwiO1xuICB9KSAvLyBQcm9wZXJ0aWVzIG9wZXJhdG9yXG4gIC5yZXBsYWNlKC9+L2d1LCAnO347JykgLy8gU3BsaXQgYnkgcHJvcGVydHkgYm91bmRhcmllc1xuICAucmVwbGFjZSgvWydcIl0/XFwuWydcIl0/KD8hW15bXSpcXF0pfFxcW1snXCJdPy9ndSwgJzsnKSAvLyBSZWluc2VydCBwZXJpb2RzIHdpdGhpbiBwcm9wZXJ0aWVzXG4gIC5yZXBsYWNlKC8lQCUvZ3UsICcuJykgLy8gUmVpbnNlcnQgdGlsZGVzIHdpdGhpbiBwcm9wZXJ0aWVzXG4gIC5yZXBsYWNlKC8lJUBAJSUvZ3UsICd+JykgLy8gUGFyZW50XG4gIC5yZXBsYWNlKC8oPzo7KT8oXFxeKykoPzo7KT8vZ3UsIGZ1bmN0aW9uICgkMCwgdXBzKSB7XG4gICAgcmV0dXJuICc7JyArIHVwcy5zcGxpdCgnJykuam9pbignOycpICsgJzsnO1xuICB9KSAvLyBEZXNjZW5kZW50c1xuICAucmVwbGFjZSgvOzs7fDs7L2d1LCAnOy4uOycpIC8vIFJlbW92ZSB0cmFpbGluZ1xuICAucmVwbGFjZSgvOyR8Jz9cXF18JyQvZ3UsICcnKTtcbiAgY29uc3QgZXhwckxpc3QgPSBub3JtYWxpemVkLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChleHApIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4cC5tYXRjaCgvIyhcXGQrKS91KTtcbiAgICByZXR1cm4gIW1hdGNoIHx8ICFtYXRjaFsxXSA/IGV4cCA6IHN1YnhbbWF0Y2hbMV1dO1xuICB9KTtcbiAgY2FjaGVbZXhwcl0gPSBleHByTGlzdDtcbiAgcmV0dXJuIGNhY2hlW2V4cHJdLmNvbmNhdCgpO1xufTtcblxuSlNPTlBhdGgucHJvdG90eXBlLnZtID0gdm1fX2RlZmF1bHRbJ2RlZmF1bHQnXTtcblxuZXhwb3J0cy5KU09OUGF0aCA9IEpTT05QYXRoO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidm0iLCJyZXF1aXJlIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsInZtX19kZWZhdWx0IiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wIiwicHJvdG90eXBlIiwicHVzaCIsImFyciIsIml0ZW0iLCJzbGljZSIsInVuc2hpZnQiLCJOZXdFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJhdm9pZE5ldyIsIm5hbWUiLCJKU09OUGF0aCIsIm9wdHMiLCJleHByIiwib2JqIiwiY2FsbGJhY2siLCJvdGhlclR5cGVDYWxsYmFjayIsIm9wdE9iaiIsImpzb24iLCJwYXRoIiwicmVzdWx0VHlwZSIsImZsYXR0ZW4iLCJ3cmFwIiwiY2FsbCIsInNhbmRib3giLCJwcmV2ZW50RXZhbCIsInBhcmVudCIsInBhcmVudFByb3BlcnR5IiwiVHlwZUVycm9yIiwiYXV0b3N0YXJ0IiwiYXJncyIsInJldCIsImV2YWx1YXRlIiwiY3VyclBhcmVudCIsImN1cnJQYXJlbnRQcm9wZXJ0eSIsImN1cnJSZXN1bHRUeXBlIiwiY3VyclByZXZlbnRFdmFsIiwiY3VyclNhbmRib3giLCJjdXJyT3RoZXJUeXBlQ2FsbGJhY2siLCJBcnJheSIsImlzQXJyYXkiLCJ0b1BhdGhTdHJpbmciLCJ1bmRlZmluZWQiLCJleHByTGlzdCIsInRvUGF0aEFycmF5IiwibGVuZ3RoIiwic2hpZnQiLCJfaGFzUGFyZW50U2VsZWN0b3IiLCJyZXN1bHQiLCJfdHJhY2UiLCJmaWx0ZXIiLCJlYSIsImlzUGFyZW50U2VsZWN0b3IiLCJoYXNBcnJFeHByIiwiX2dldFByZWZlcnJlZE91dHB1dCIsInJlZHVjZSIsInJzbHQiLCJ2YWxPclBhdGgiLCJjb25jYXQiLCJwb2ludGVyIiwidG9Qb2ludGVyIiwiX2hhbmRsZUNhbGxiYWNrIiwiZnVsbFJldE9iaiIsInR5cGUiLCJwcmVmZXJyZWRPdXRwdXQiLCJ2YWwiLCJwYXJlbnRQcm9wTmFtZSIsImxpdGVyYWxQcmlvcml0eSIsInJldE9iaiIsImxvYyIsIngiLCJhZGRSZXQiLCJlbGVtcyIsImZvckVhY2giLCJ0IiwiX3dhbGsiLCJtIiwibCIsIl94IiwidiIsInAiLCJwYXIiLCJwciIsImNiIiwidGVzdCIsIl9zbGljZSIsImluZGV4T2YiLCJfZXZhbCIsInJlcGxhY2UiLCJhZGRUeXBlIiwidmFsdWVUeXBlIiwiaW5jbHVkZXMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImxvY1Byb3AiLCJwYXJ0cyIsInNwbGl0IiwicGFydCIsInJldHQiLCJ0bXAiLCJ0bCIsInR0Iiwic3BsaWNlIiwiZiIsIm4iLCJpIiwia2V5cyIsImxlbiIsInN0ZXAiLCJwYXJzZUludCIsInN0YXJ0IiwiZW5kIiwiTWF0aCIsIm1heCIsIm1pbiIsImNvZGUiLCJfdiIsIl92bmFtZSIsIl8kX3BhcmVudFByb3BlcnR5IiwiXyRfcGFyZW50IiwiXyRfcHJvcGVydHkiLCJfJF9wYXRoIiwiXyRfcm9vdCIsIl8kX3YiLCJydW5Jbk5ld0NvbnRleHQiLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsImNhY2hlIiwicGF0aEFyciIsInRvU3RyaW5nIiwic3VieCIsIm5vcm1hbGl6ZWQiLCIkMCIsIiQxIiwicHJvcCIsInVwcyIsImpvaW4iLCJtYXAiLCJleHAiLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsonpath-plus/dist/index-node-cjs.js\n");

/***/ })

};
;